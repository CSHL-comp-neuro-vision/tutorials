function SpeedTest% SpeedTest%% Time MATLAB operations.% % SpeedTest's results, especially the summary it prints at the end, will% help you understand what MATLAB does quickly, and will teach you to% avoid a few things that MATLAB does very slowly.% % To optimize your programs for speed use MATLAB's invaluable PROFILE% command. PROFILE will tell you where you're spending most of your time.% Try to change that code to make it run faster. Knowing SpeedTest's% results will help you avoid MATLAB's slow operations.% % See also PROFILE.% % NOTES ON TIMING% % All we care about here is the time per iteration. So we ignore the time% taken by the (slow) first iteration of the loop, and report only the% incremental time taken by subsequent iterations, i.e. the slope of the t% vs n graph. The rationale is that long run times are usually due to code% that's executed many times, so we can neglect any code that's executed% only once.% % If you have any disk drives with removable media (e.g. floppy, zip,% jaz), don't leave them empty (insert a disk) when you want to eliminate% interruptions. Macintosh drivers for removable disks periodically% (perhaps once a second) check empty drives to see if a disk has been% inserted, and this operation may tie up the Mac for several ms at a% time, which can have a big impact on the timing of a 13 ms loop, e.g.% showing a real time movie.% % SpeedTest tries to edit out such interruptions by repeating every% measurement several times, and keeping only the minimum time. This% relies on the timing intervals being sufficiently brief that they are% only rarely interrupted. Thus this trick works best if n (the number of% repetions of the timing loop) is relatively small. Consequently if you% vary the number of iterations, n, you'll find that the variance of the% measurement increases when n gets bigger, which is probably not what% you expected.% % Note too that the very first execution of the code in a loop is likely% to be slow because any mex functions that are used for the first time% must be loaded from disk into memory, and any variables that are used% for the first time need to be allocated. Usually one eliminates these% delays from critical-time loops by using the functions and variables in% advance of the loop. Here we don't need to because the min trick that we% introduced to eliminate the effect of interrupts also discards the% extra-long first measurement.% 4/13/97  dgp  Wrote it.% 4/13/97  dhb  Check for existence of bitand.mex, new in V5.% 4/15/97  dgp	Cosmetic.% 5/1/97   dgp	Report FOR loop time.% 6/3/97   dgp	Warn that patching GetMenuBar breaks the MATLAB debugger.% 6/4/97   dgp	Add conv2.% 8/3/97   dgp	Add ">". Check before complaining.% 8/17/97  dgp	Systematically check all ops, applied to scalars, arrays, and combinations.% 8/17/97  dgp	Expanded the summary.% 8/17/97  dgp	Use DoNothing.mex if available.% 1/17/98  dgp	Rewrote the timing code to measure the incremental time per iteration, % 				after the first. SpeedTest now runs faster, and the results are%				nearly independent of n.% 6/16/00  dgp	Made compatible with new version of SCREEN('Computer').n=10; % The basic number of repetitions to time for.nn=[1 n;1 n;1 n;1 n]; % The complete set of values of n to use. The multiple rows are used to% repeat the measurement, of which only the minimum time will be kept, to minimize the effect% of occasional long interrupts (e.g. 2 ms once a second).tt=nn;j=0;k=1;t1=0;t2=0;x=0;xx=magic(32);yy=xx;zz=fliplr(xx);cputime;bestTime=Inf;bestMexTime=Inf;fprintf('SpeedTest will now time MATLAB''s basic operations. %d iterations per test.\n',n);fprintf('All times are per iteration, omitting the loop overhead (in first row of table).\n');fprintf('We ignore the first iteration, which is usually slower.\n');fprintf('x,j,k are scalars. xx,yy,zz are %.0f-element arrays.\n',length(xx(:)));fprintf('\nEmpty FOR loop\n');for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms\n',p(1)*1e3);loopTime=p(1);fprintf('Operate on scalar.\n');x=j;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=j;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=j				%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);xk=p(1)-loopTime;x=+j;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=+j;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=+j				%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);x=-j;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=-j;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=-j				%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);minusTime=p(1)-loopTime;x=~j;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=~j;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=~j				%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);notTime=p(1)-loopTime;x=fix(j);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=fix(j);	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=fix(j)			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);x=round(j);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=round(j);	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=round(j)			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);x=sign(j);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=sign(j);	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=sign(j)			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);x=sin(j);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=sin(j);	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=sin(j)			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);fprintf('Operate on scalar and scalar.\n');for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=j+0;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);%fprintf('%8.3f ms  x=j+0				%% built-in function\n',1000*(p(1)-loopTime));%bestTime=min(bestTime,p(1)-loopTime);xk0=p(1)-loopTime;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=j+k;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=j+k				%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);statementTime=p(1)-loopTime;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=j-k;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=j-k				%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=j*k;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=j*k				%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=j/k;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=j/k				%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);x=j>k;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=j>k;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=j>k				%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);x=j==k;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=j==k;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=j==k				%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);x=j&k;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=j&k;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=j&k				%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);x=j|k;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=j|k;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=j|k				%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);x=j^k;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=j^k;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=j^k				%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);x=atan2(j,k);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=atan2(j,k);	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=atan2(j,k)		%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);if 0	x=cputime;	for k=1:length(nn(:))		t0=cputime;		for j=1:nn(k)			x=cputime;		end		tt(k)=cputime-t0;	end	p=polyfit(nn(1,:),min(tt),1);	fprintf('%8.3f ms  x=cputime			%% built-in function\n',1000*(p(1)-loopTime));	bestTime=min(bestTime,p(1)-loopTime);endif exist('latcfilt')	% in signal toolbox	x=latcfilt(j,k);	for k=1:length(nn(:))		t0=cputime;		for j=1:nn(k)			x=latcfilt(j,k);		end		tt(k)=cputime-t0;	end	p=polyfit(nn(1,:),min(tt),1);	fprintf('%8.3f ms  x=latcfilt(j,k)	%% mex\n',1000*(p(1)-loopTime));	bestMexTime=min(bestMexTime,p(1)-loopTime);endx=conv2(j,k);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		x=conv2(j,k);	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  x=conv2(j,k)		%% mex\n',1000*(p(1)-loopTime));bestMexTime=min(bestMexTime,p(1)-loopTime);if exist('bitand')		% comes with MATLAB 5, but not with MATLAB 4	x=bitand(j,k);	for k=1:length(nn(:))		t0=cputime;		for j=1:nn(k)			x=bitand(j,k);		end		tt(k)=cputime-t0;	end	p=polyfit(nn(1,:),min(tt),1);	fprintf('%8.3f ms  x=bitand(j,k)		%% mex\n',1000*(p(1)-loopTime));	bestMexTime=min(bestMexTime,p(1)-loopTime);endif exist('DoNothing')	fprintf('Call dummy MEX function. (Ignores inputs. Returns empty matrix for each explicit output arg.)\n');	DoNothing;	for k=1:length(nn(:))		t0=cputime;		for j=1:nn(k)			DoNothing;		end		tt(k)=cputime-t0;	end	p=polyfit(nn(1,:),min(tt),1);	fprintf('%8.3f ms  DoNothing			%% mex\n',1000*(p(1)-loopTime));	bestMexTime=min(bestMexTime,p(1)-loopTime);	DoNothing(j,k);	for k=1:length(nn(:))		t0=cputime;		for j=1:nn(k)			DoNothing(j,k);		end		tt(k)=cputime-t0;	end	p=polyfit(nn(1,:),min(tt),1);	fprintf('%8.3f ms  DoNothing(j,k)		%% mex\n',1000*(p(1)-loopTime));	bestMexTime=min(bestMexTime,p(1)-loopTime);	x=DoNothing;	for k=1:length(nn(:))		t0=cputime;		for j=1:nn(k)			x=DoNothing;		end		tt(k)=cputime-t0;	end	p=polyfit(nn(1,:),min(tt),1);	fprintf('%8.3f ms  x=DoNothing		%% mex\n',1000*(p(1)-loopTime));	bestMexTime=min(bestMexTime,p(1)-loopTime);	x=DoNothing(j,k);	for k=1:length(nn(:))		t0=cputime;		for j=1:nn(k)			x=DoNothing(j,k);		end		tt(k)=cputime-t0;	end	p=polyfit(nn(1,:),min(tt),1);	fprintf('%8.3f ms  x=DoNothing(j,k)	%% mex\n',1000*(p(1)-loopTime));	bestMexTime=min(bestMexTime,p(1)-loopTime);endfprintf('Operate on array.\n');for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy				%% built-in function\n',1000*(p(1)-loopTime));yyTime=p(1)-loopTime;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=+yy;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=+yy				%% built-in function\n',1000*(p(1)-loopTime));yyPlusTime=p(1)-loopTime;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=-yy;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=-yy				%% built-in function\n',1000*(p(1)-loopTime));for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=~yy;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=~yy				%% built-in function\n',1000*(p(1)-loopTime));xx=fix(yy);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=fix(yy);	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=fix(yy)			%% built-in function\n',1000*(p(1)-loopTime));xx=round(yy);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=round(yy);	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=round(yy)		%% built-in function\n',1000*(p(1)-loopTime));yyRoundTime=p(1)-loopTime;xx=sign(yy);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=sign(yy);	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=sign(yy)		%% built-in function\n',1000*(p(1)-loopTime));yySignTime=p(1)-loopTime;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=sin(yy);	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=sin(yy)			%% built-in function\n',1000*(p(1)-loopTime));fprintf('Operate on array and scalar.\n');for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy+j;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy+j			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy-j;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy-j			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);yyMinusjTime=p(1)-loopTime;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy*j;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy*j			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy/j;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy/j			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);xx=yy>j;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy>j;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy>j			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);yyGreaterThanjTime=p(1)-loopTime;xx=yy==j;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy==j;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy==j			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);xx=yy&j;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy&j;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy&j			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);xx=yy|j;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy|j;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy|j			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);xx=yy.^j;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy.^j;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy.^j			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);xx=atan2(yy,j);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=atan2(yy,j);	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=atan2(yy,j)		%% built-in function\n',1000*(p(1)-loopTime));if exist('bitand')		% MATLAB 5	xx=bitand(yy,j);	for k=1:length(nn(:))		t0=cputime;		for j=1:nn(k)			xx=bitand(yy,j);		end		tt(k)=cputime-t0;	end	p=polyfit(nn(1,:),min(tt),1);	fprintf('%8.3f ms  xx=bitand(yy,j)	%% mex\n',1000*(p(1)-loopTime));	bestMexTime=min(bestMexTime,p(1)-loopTime);endfprintf('Operate on array and array.\n');for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy+zz;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy+zz			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);operationTime=(p(1)-loopTime)/length(xx(:));for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy-zz;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy-zz			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);yyMinusjTime=p(1)-loopTime;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy.*zz;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy.*zz			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy./zz;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy./zz			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);xx=yy>zz;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy>zz;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy>zz			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);yyGreaterThanjTime=p(1)-loopTime;xx=yy==zz;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy==zz;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy==zz			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);xx=yy&zz;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy&zz;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy&zz			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);yyAndzzTime=p(1)-loopTime;xx=yy|zz;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy|zz;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy|zz			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);xx=yy.^zz;for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=yy.^zz;	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=yy.^zz			%% built-in function\n',1000*(p(1)-loopTime));bestTime=min(bestTime,p(1)-loopTime);xx=atan2(yy,zz);for k=1:length(nn(:))	t0=cputime;	for j=1:nn(k)		xx=atan2(yy,zz);	end	tt(k)=cputime-t0;endp=polyfit(nn(1,:),min(tt),1);fprintf('%8.3f ms  xx=atan2(yy,zz)	%% built-in function\n',1000*(p(1)-loopTime));if exist('bitand')		% MATLAB 5	xx=bitand(yy,zz);	for k=1:length(nn(:))		t0=cputime;		for j=1:nn(k)			xx=bitand(yy,zz);		end		tt(k)=cputime-t0;	end	p=polyfit(nn(1,:),min(tt),1);	fprintf('%8.3f ms  xx=bitand(yy,zz)	%% mex\n',1000*(p(1)-loopTime));	bestMexTime=min(bestMexTime,p(1)-loopTime);	yyBitandzzTime=p(1)-loopTime;else	yyBitandzzTime=nan;endif exist('SCREEN')	cmptr=SCREEN('Computer');	fprintf('\n%s''s %s, %s\n',cmptr.owner,cmptr.model,cmptr.system);else	fprintf('\n%s\n',computer);	if exist('gestalt')		bits = gestalt('sysa');	 	if bits(32)			type='68K';		end		if bits(31)			type='PowerPC';		end		fprintf('%s Macintosh',type);		bits=eval('gestalt(''pclk'')','[]');		if ~isempty(bits)			hz=0;			for i=1:32				hz=hz*2+bits(i);			end			fprintf(' running at %.0f MHz',hz/1e6);		end		fprintf('.\n');	endend	fprintf('\nSUMMARY: MATLAB %s is quick. The loop overhead is only \n',version);fprintf('%.0f microseconds per iteration (after the first). The large %.0f:1 ratio\n',loopTime*1e6,statementTime/operationTime);fprintf('of the roughly %.0f microsecond statement overhead to the roughly\n',1e6*statementTime);fprintf('%.2f microseconds per elementary operation (~,+,-,*,/,==,&,|,sin,sign)\n',1e6*operationTime);fprintf('is a defining characteristic of the language. (Thus the run time of\n');fprintf('statements that operate on less than %.0f elements is mostly spent\n',statementTime/operationTime);fprintf('processing the statement, not the elements.) However, there are some\n');fprintf('anomalies:\n');count=0;if notTime>1.5*minusTime	count=count+1;	fprintf('%d. With scalars, the NOT function is slow.\n',count);	fprintf('   x=~j takes %.1f times as long as x=-j.\n',notTime/minusTime);endif yyBitandzzTime/yyAndzzTime>1.5	count=count+1;	fprintf('%d. With arrays, it is surprising that unary plus takes any time at all.\n',count);	fprintf('   xx=+yy takes %.0f times as long as xx=yy.\n',yyPlusTime/yyTime);endif yyBitandzzTime/yyAndzzTime>1.5	count=count+1;	fprintf('%d. With arrays, the bit-wise logical functions are terribly slow.\n',count);	fprintf('   bitand(yy,zz) takes %.0f times as long as yy&zz.\n',yyBitandzzTime/yyAndzzTime);endif yyGreaterThanjTime>1.5*yyMinusjTime	count=count+1;	fprintf('%d. With arrays, the comparison operators are slow.\n',count);	fprintf('   yy>j takes %.1f times as long as yy-j.\n',yyGreaterThanjTime/yyMinusjTime);endif yyRoundTime/yySignTime>1.5	count=count+1;	fprintf('%d. With arrays, FIX and ROUND are slow.\n',count);	fprintf('   round(yy) takes %.1f times as long as sign(yy).\n',yyRoundTime/yySignTime);endif xk>xk0 & xk>0 & xk0>0	% Fixed in MATLAB 5.1. Yay!	count=count+1;	fprintf('%d. It makes no sense, but executing ''x=j'' takes %.1f times longer \n',count,xk/xk0);	fprintf('   than ''x=j+0''.\n');endif bestMexTime-bestTime>0.1e-3	% In MATLAB 5.2 this has been reduced to a mere 0.1 ms on a PowerMac 6100. Yay!	count=count+1;	fprintf('%d. MATLAB takes %.3f ms longer to call a MEX than a built-in function.\n',count,(bestMexTime-bestTime)*1e3);end