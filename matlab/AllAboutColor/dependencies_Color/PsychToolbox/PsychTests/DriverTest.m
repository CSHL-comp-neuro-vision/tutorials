function driver=DriverTest(w,secs)% driver = DriverTest(windowPtrOrScreenNumber,[secs])% % DriverTest makes elaborate measurements to characterize the timing% of a video driver. It is primarily intended as a subroutine for% ScreenTest.m. The results are returned as struct, with labeled% fields. Some of the fields are boolean diagnostic conclusions about% the driver. (Unanswered boolean questions receive an empty matrix.)% If windowPtrOrScreenNumber is an array, then "driver" will be too,% with separate data for each window/screen.% % driver.hz                          Frame rate% driver.setClutDriverAwaitsBlanking Does SetClut wait for blanking?% windowPtrOrScreenNumber            Select a screen% secs                               How long to measure for (default is 0.2 s),%                                    to increase accuracy.% % driver.priority                    Processor priority at which most testing (not "low") was done.% driver.interruptOnBlanking         Does the "blanking" interrupt actually %                                    occur at blanking, or at some other%                                    time (eg System Tick)? (Michael Bache %                                    reported this for one PowerBook model.)% driver.setClutFraction             How long (frames) SetClut takes (minimum).% driver.suppresses                  How long (frames) SetClut suppresses interrupts.% % driver.priorityLow                 Processor priority, MaxPriorityForBlankingInterrupt,%                                    at which "low" testing was done.% driver.interruptOnBlankingLow      Tested at low priority.% driver.setClutFractionLow            " % driver.suppressesLow                 " % % % DriverTest.m is long and subtle because it measures with minimal% assumptions. We assess whether SetClut waits for blanking without% use of the "blanking" interrupt. If SetClut does wait for blanking,% then we determine whether the "blanking" interrupt indeed occurs at% the end of SetClut.% % Also see ScreenTest, FrameRate, BlankingInterruptRate, and "SCREEN FrameRate?"% % Denis Pelli% 14 July 1998 dgp wrote it, as "FrameRate.m".% 7/21/98 dgp Steve Engel reported that ScreenTest hung the Mac if he ran it first. That turns out to be due%				to the fact that SetClutSecs failed to make sure all needed functions were pre-loaded before%				calling Rush. Fixed.% 7/22/98 dgp Fixed typo: changed "getClutFraction" to "setClutFraction" throughout this file.% 7/24/98 dgp Configure prefs in SetClutSecs. Hopefully this will fix the twice-as-high frame rate in the%             ScreenTest report sent by Steve Engel for his G3. Rewrote the code that computes setClutFraction%             to always give an answer in the range 0 to 1.% 8/2/98 dgp Reduced default secs from 0.3 to 0.2.% 8/11/98 dgp Enhanced warnings to provide more relevant info.% 8/11/98 dgp Use SCREEN FrameRate for quick answer.% 8/13/98 dgp Expand warnings to deal with multiple-frame delays associated with FileSharing.% 8/13/98 dgp Added missing parenthesis to new fprintf statements. As noted by Steve Engel.% 3/26/99 dgp Added DescribeComputer and DescribeScreen to error report.% 4/1/99 dgp  Made the test for setClutDriverAwaitsBlanking more robust, in response to false alarms reported%             by Cassandra Moore, seymour@pop.ucla.edu% 4/12/99 dgp Enhanced printout to try to track down false alarms reported anew by Cassandra.% 4/22/99 dhb Add note about caching to the help text.% 4/22/99 dgp Add more about caching.% 5/20/99 dgp Redefined deadError to avoid spurious warnings.% 6/10/99 dgp Increased tolerance in interruptOnBlanking test from 1 to 3 ms, to avoid spurious warnings on PowerMac 6100.% 10/3/99 dgp Use nan instead of [] for float parameters, to work around bug in FPRINTF. Boolean parameters still%             use [] to indicate unknown value.% 10/3/99 dgp Removed this code from FrameRate.m to create this new file, DriverTest.m.% 10/4/99 dgp Test at both low and high priority (with and without blanking interrupt).% 10/5/99 dgp Comment out the printing of period, periodA, etc. Add "driver" struct to WARNING messages. % 10/31/99 dgp Polished the setClutFraction algorithm and associated diagnostic printouts.% 10/31/99 dgp Following SetClutDriverWaitsForBlanking in GetScreenInfo.c, use max of period and interruptPeriod %				in computing delayA. This yields a better test in cases where the driver doesn't wait and%				period is very short.% 11/3/99 dgp Fine tuning of the measurement of setClutFraction. I now set BlankingDuration to zero while%				we're making the measurement. I discovered that the period measurement, when the driver%				doesn't wait, is better with a 3 ms delay in the loop. I don't understand why this should%				be so, but since i'm trying to report the minimum time that SetClut will take, i decided%				to use this optimal condition. (So far tested only on my PowerMac G3/300.)% 2/1/00 dgp Specify priority in Warning about not waiting for blanking.% 2/4/00 dgp Don't test at priority exceeding MaxPriority('GetSecs').% 2/10/00 dgp Set driver.setClutDriverAwaitsBlanking true only if setclut period is very close to % 				interruptPeriod. On our VillageTronic MacPicasso 540 in G3 the values are 7.5 ms period % 				and 10 ms interruptPeriod.% 4/16/00 dgp Don't warn that interruptOnBlanking may be off, since all the warnings seem to be false alarms.% 4/16/00 dgp Distinguish between inconsistent frame rate and wrong setting of SetClutDriverWaitsForBlanking.% 4/17/00 dgp SetClutDriverWaitsForBlanking warning notes difference in number of entries loaded.%				delay is now always period/2.if nargin<1 | nargin>2 | nargout>4 | isempty(w) | ~isa(w,'double') | isnan(w)	error('Usage: driver=DriverTest(windowPtrOrScreenNumber,[secs])');endif nargin<2	secs=0.2;endif length(w)>1	for i=1:length(w(:))		driver(i)=DriverTest(w(i),secs);	end	returnend% w is scalar% driver.priorityLow                 Processor priority, MaxPriorityForBlankingInterrupt,%                                    at which "low" testing was done.% driver.interruptOnBlankingLow      Tested at low priority.% driver.setClutFractionLow            " driver=DriverTestPriority(w,secs,MaxPriority('GetSecs'));if MaxPriority('GetSecs') > MaxPriority(w,'BlankingInterrupt')	driverLow=DriverTestPriority(w,secs,MaxPriority(w,'BlankingInterrupt'));else	fprintf('  WARNING: maximum priority for GetSecs is %g, not high enough to suppress interrupts.\n',MaxPriority('GetSecs'));	fprintf('  SUGGESTION: for better timing, upgrade to a PowerMac running Mac OS 8.6 or better.\n');	driverLow=driver;enddriver.priorityLow=driverLow.priority;driver.interruptOnBlankingLow=driverLow.interruptOnBlanking;driver.setClutFractionLow=driverLow.setClutFraction;driver.setClutDriverAwaitsBlankingLow=driverLow.setClutDriverAwaitsBlanking;return;function driver=DriverTestPriority(w,secs,maxPriority)driver.secs=secs;driver.windowPtrOrScreenNumber=w;driver.setClutDriverAwaitsBlanking=[];driver.interruptOnBlanking=[];driver.setClutFraction=nan;clut=SCREEN(w,'GetClut');if isempty(clut)	clut=ClutDefault(w);end% clut=clut(1,:);% measure periodinterruptPeriod=1/BlankingInterruptRate(w,secs);[period,driver.priority]=SetClutSecs(w,maxPriority,clut,0.003);% When SetClut doesn't wait, the period may be almost nothing. delayA=period/2;if period<interruptPeriod/1.5 | period>2.1*interruptPeriod	driver.setClutDriverAwaitsBlanking=0;	periodA=nan;else	% Does SetClut wait? Evaluate error for each hypothesis	periodA=SetClutSecs(w,maxPriority,clut,delayA);	waitError=min(abs(periodA-[1 2]*period));  % if driver waits, predict that periodA is 1 or 2 periods	noWaitError=abs(periodA-(delayA+period));    % if driver doesn't wait, predict periodA==period+delayA 	deadError=max(abs([period periodA-delayA]-0.4*interruptPeriod)); % predict driver waits during first 0.4 of frame	badError=min(abs(periodA-[0 3:10]*period)); % it's a bad sign if periodA is 0 or 3 or more periods.	e=min([waitError,noWaitError,deadError,badError]);	if waitError==e		driver.setClutDriverAwaitsBlanking=1;	end	if noWaitError==e | deadError==e		driver.setClutDriverAwaitsBlanking=0;	end	if badError==e		if 1			fprintf('  WARNING: couldn''t decide whether SetClut waits for blanking.\n');			format compact			fprintf('  ');			driver			format loose			fprintf('  waitError %.1f ms,noWaitError %.1f ms,deadError %.1f ms,badError %.1f ms\n',1000*waitError,1000*noWaitError,1000*deadError,1000*badError);			fprintf('  SetClut %.1f Hz (%.0f ms) vs interrupt %.1f Hz (%.0f ms)\n',1/period,1000*period,1/interruptPeriod,1000*interruptPeriod);			fprintf('  pixelSize %d\n',SCREEN(w,'PixelSize'));			fprintf('  SetClutDriverWaitsForBlanking %d\n',SCREEN(w,'Preference','SetClutDriverWaitsForBlanking'));			fprintf('  SetClut period %.0f ms, or %.0f ms with delay %.0f ms\n',1000*[period,periodA,delayA]);			ss=[InterruptToSetClutEndSecs(w,maxPriority,clut,0,5) InterruptToSetClutEndSecs(w,maxPriority,clut,max(period,interruptPeriod)/2,5)];			if all(abs(ss)<0.001 | abs(ss-interruptPeriod)<0.001)				driver.interruptOnBlanking=1;			else				driver.interruptOnBlanking=0;			end			fprintf('  InterruptToSetClutEndSecs    ');			fprintf(' %.0f',1000*sort(ss));			fprintf(' ms\n');			fprintf('  interruptOnBlanking %d\n',driver.interruptOnBlanking);			fprintf('  Please send this report to denis & david: psychtoolbox@psych.nyu.edu\n\n');			%DescribeScreen(w)		end		driver.setClutDriverAwaitsBlanking=[];		driver.hz=nan;		driver.interruptOnBlanking=[];		driver.setClutFraction=nan;		return	endendif driver.setClutDriverAwaitsBlanking	% driver.setClutFraction is the minimum fraction of the tight-loop period required by SetClut.	% Measure how big a delay we can insert without doubling the period.	driver.setClutFraction=nan;	for delayB=0:0.001:period		periodB=SetClutSecs(w,maxPriority,clut,delayB,10);		if periodB/period>1.5			break		end		driver.setClutFraction=(periodB-delayB)/period;	end	% driver.interruptOnBlanking = Does the so-called "blanking" interrupt occur at end of SetClut?	% 4/16/00 dgp This test appears to be useless. Firstly, the interrupt is in fact driven by blanking on nearly	% all devices. The sole exception I know of is one PowerBook model reported by Michael Bach. Secondly, the latencies	% measured by InterruptToSetClutEndSecs seem to be much more variable than I'd expect 	% (e.g. 1 2 3 3 4 4 4 4 5 5 ms on Matteo's MacPicasso 850, when running at 160 Hz) even though I'm reasonably	% sure that the interrupt is driven by blanking. For the time being I'll leave all the normal reporting in place,	% but won't issue any special warning just because this flag comes up false.	ss=[InterruptToSetClutEndSecs(w,maxPriority,clut,0,5) InterruptToSetClutEndSecs(w,maxPriority,clut,max(period,interruptPeriod)/2,5)];	sss=rem(ss,interruptPeriod); % discount multiples of a period. Filesharing may be on.	if all(abs(sss)<0.004 | abs(sss-interruptPeriod)<0.004)		driver.interruptOnBlanking=1;	else		driver.interruptOnBlanking=0;	end	if abs(log10(period/interruptPeriod))>log10(1.03) | ~SCREEN(w,'Preference','SetClutDriverWaitsForBlanking')		fprintf('  WARNING from DriverTest:\n');		if abs(log10(period/interruptPeriod))>log10(1.03)			fprintf('  Inconsistent frame rate: SetClut %.0f Hz vs interrupt %.0f Hz.\n',1/period,1/interruptPeriod);		end		if ~SCREEN(w,'Preference','SetClutDriverWaitsForBlanking')			fprintf('  SetClut does wait (at priority %g), yet SetClutDriverWaitsForBlanking is 0.\n',driver.priority);			fprintf('  Perhaps SetClut waits when loading %d entries, but not when loading only 1.\n',size(clut,1));		end		format compact		fprintf('  ');		driver		format loose		if ~isnan(periodA)			fprintf('  waitError %.1f ms,noWaitError %.1f ms,deadError %.1f ms,badError %.1f ms\n',1000*waitError,1000*noWaitError,1000*deadError,1000*badError);		end		fprintf('  SetClut %.1f Hz (%.0f ms) vs interrupt %.1f Hz (%.0f ms)\n',1/period,1000*period,1/interruptPeriod,1000*interruptPeriod);		fprintf('  pixelSize %d\n',SCREEN(w,'PixelSize'));		fprintf('  SetClutDriverWaitsForBlanking %d\n',SCREEN(w,'Preference','SetClutDriverWaitsForBlanking'));		fprintf('  SetClut period %.0f ms, or %.0f ms with delay %.0f ms\n',1000*[period,periodA,delayA]);		fprintf('  InterruptToSetClutEndSecs    ');		fprintf(' %.0f',1000*sort(ss));		fprintf(' ms\n');		fprintf('  interruptOnBlanking %d\n',driver.interruptOnBlanking);		fprintf('  Please send this report to denis & david:\n');		fprintf('  web mailto:psychtoolbox@psych.nyu.edu\n\n');	end	% Use whichever method of timing is most accurate. Running at higher priority increases accuracy	% by reducing interruptions by other processes.	if MaxPriority(w,'GetSecs','SetClut')>MaxPriority(w,'BlankingInterrupt')		driver.hz=1/period;	else		driver.hz=1/interruptPeriod;	endelse	if SCREEN(w,'Preference','SetClutDriverWaitsForBlanking')		fprintf('  WARNING: DriverTest: SetClut doesn''t wait (at priority %g), yet SetClutDriverWaitsForBlanking is 1.\n',driver.priority);		format compact		fprintf('  ');		driver		format loose		if ~isnan(periodA)			fprintf('  waitError %.1f ms,noWaitError %.1f ms,deadError %.1f ms,badError %.1f ms\n',1000*waitError,1000*noWaitError,1000*deadError,1000*badError);		end		fprintf('  SetClut %.1f Hz (%.0f ms) vs interrupt %.1f Hz (%.0f ms)\n',1/period,1000*period,1/interruptPeriod,1000*interruptPeriod);		fprintf('  pixelSize %d\n',SCREEN(w,'PixelSize'));		fprintf('  setClutDriverAwaitsBlanking %d\n',driver.setClutDriverAwaitsBlanking);		fprintf('  SetClutDriverWaitsForBlanking %d\n',SCREEN(w,'Preference','SetClutDriverWaitsForBlanking'));		fprintf('  SetClut period %.0f ms, or %.0f ms with delay %.0f ms\n',1000*[period,periodA,delayA]);		if 1			ss=[InterruptToSetClutEndSecs(w,maxPriority,clut,0,5) InterruptToSetClutEndSecs(w,maxPriority,clut,max(period,interruptPeriod)/2,5)];			if all(abs(ss)<0.001 | abs(ss-interruptPeriod)<0.001)				driver.interruptOnBlanking=1;			else				driver.interruptOnBlanking=0;			end			fprintf('  InterruptToSetClutEndSecs    ');			fprintf(' %.0f',1000*sort(ss));			fprintf(' ms\n');			fprintf('  interruptOnBlanking %d\n',driver.interruptOnBlanking);		end		fprintf('  Please send this report to denis & david: psychtoolbox@psych.nyu.edu\n\n'); 	end	driver.interruptOnBlanking=[]; % Probably yes, but we don't know.	driver.hz=1/interruptPeriod;	delay=0.003;	period=SetClutSecs(w,maxPriority,clut,delay);	driver.setClutFraction=(period-delay)*driver.hz;	setClutBlanking=SCREEN(w,'Preference','SetClutCallsWaitBlanking');endreturnfunction [s,priority]=SetClutSecs(w,maxPriority,clut,delaySecs,reps)% Times the period of a loop that calls SetClut plus a delay.% If SetClut waits for end-of-frame blanking, then the period should always be a multiple of the frame period.% If SetClut doesn't wait, then the period will be a fixed time plus delaySecs.if nargin<2 | isempty(maxPriority)	maxPriority=7;endif nargin<3 | isempty(clut)	clut=SCREEN(w,'GetClut');	if isempty(clut) % some video drivers fail to support GetClut in some modes		clut=ClutDefault(w);	endendif nargin<4 | isempty(delaySecs)	delaySecs=0;endif nargin<5 | isempty(reps)	reps=30;endoldSetClutCallsWaitBlanking=SCREEN(w,'Preference','SetClutCallsWaitBlanking',0);oldSetClutDriverWaitsForBlanking=SCREEN(w,'Preference','SetClutDriverWaitsForBlanking',1);oldBlankingDuration=SCREEN(w,'Preference','BlankingDuration',0);priority=MaxPriority(w,'SetClut','WaitSecs','GetSecs');priority=min(priority,maxPriority);SCREEN('Screens');WaitSecs(0);GetSecs; % Make sure all Rushed functions are in memory.t=1:reps+1;i=0;loop={	'SCREEN(w,''SetClut'',clut);'	'for i=1:reps+1;'		'WaitSecs(delaySecs);'		'SCREEN(w,''SetClut'',clut);'		't(i)=GetSecs;'	'end;'};Rush(loop,priority);SCREEN(w,'Preference','SetClutCallsWaitBlanking',oldSetClutCallsWaitBlanking);SCREEN(w,'Preference','SetClutDriverWaitsForBlanking',oldSetClutDriverWaitsForBlanking);SCREEN(w,'Preference','BlankingDuration',oldBlankingDuration);s=median(diff(t));returnfunction [ss,priority]=InterruptToSetClutEndSecs(w,maxPriority,clut,delaySecs,reps)% The time of return from SetClut relative to the most recent "blanking" interrupt.% If SetClut always ends on the blanking event, and the "blanking" interrupt always occurs% at blanking, then the delay should be zero. In fact, on my PowerBook Series G3, the returned% values I get suggest that the interrupt occurs 1 ms after the return from SetClut. Thus I get% returned times, from interrupt to return from SetClut of 17 ms (+1 period) or -1 ms. % I think blanking is about 1 ms long. Perhaps SetClut ends at the beginning of blanking and% the interrupt occurs at the end.%% In analyzing the data supplied by this routine, the first hypothesis is that the times (with% some error due to spurious interrupts by other processes) are 0 and 1 period. If SetClut end% and the "blanking" interrupt are not synched, then the returned times ought to be more or less% uniformly distributed over the range 0 to interruptPeriod. (The value can be slightly negative,% perhaps -1 ms, because we call PeekBlanking two statements after calling SetClut.if nargin<2 | isempty(maxPriority)	maxPriority=7;endif nargin<3 | isempty(clut)	clut=SCREEN(w,'GetClut');	if isempty(clut)		clut=ClutDefault(w);	endendif nargin<4 | isempty(delaySecs)	delaySecs=0;endif nargin<5 | isempty(reps)	reps=3;endpriority=MaxPriority(w,'WaitSecs','GetSecs','PeekBlanking');priority=min(priority,maxPriority);oldSetClutCallsWaitBlanking=SCREEN(w,'Preference','SetClutCallsWaitBlanking',0);oldSetClutPunchesBlankingClock=SCREEN(w,'Preference','SetClutPunchesBlankingClock',0);ss=1:reps;loop={	'for i=1:reps;'		'WaitSecs(delaySecs);'		'SCREEN(w,''SetClut'',clut);'		'ss(i)=GetSecs;'		'[frame,tInterrupt]=SCREEN(w,''PeekBlanking'');'		'ss(i)=ss(i)-tInterrupt;'	'end;'	'delaySecs=GetSecs;'	'delaySecs=GetSecs-delaySecs;'};WaitSecs(0);SCREEN('Screens');GetSecs; % Make sure all Rushed functions are in memory.Rush(loop,priority);SCREEN(w,'Preference','SetClutCallsWaitBlanking',oldSetClutCallsWaitBlanking);SCREEN(w,'Preference','SetClutPunchesBlankingClock',oldSetClutPunchesBlankingClock);ss=ss-delaySecs; % remove overheadreturn