% PutImageTest%% Transfer an RGB image from MATLAB arrays to a SCREEN window, and back. %% Please don't use SCREEN 'PutColorImage' and 'GetColorImage', which may % become obsolete soon, in your new programs. Instead you should use 'PutImage'% and 'GetImage'. The only thing that 'PutColorImage' does that 'PutImage'% doesn't do, is to accept three separate r, g, b arrays. In that case, you% should use the CAT function to concatenate them into one rgb array:% rgb=cat(3,r,g,b);% and then pass the combined rgb array to PutImage.% SCREEN(w,'PutImage',rgb);% 3/27/98  dhb  Wrote it, as ColorImageTest.% 3/31/98  dgp	Cosmetic changes; use the new BlackIndex and WhiteIndex.% 3/31/98  dgp	Test MxNx3 images as well. Test PutImage. % 3/31/98  dgp	Test pixelSize 16 and 32. % 3/31/98  dgp	More PutImage tests.% 3/31/98  dgp	Test double and uint8.% 3/31/98  dgp	Test more pixelSizes.% 4/6/98	 dgp	Use 'PixelSizes'.% 4/6/98	 dgp	Renamed: PutImageTest% ParameterswhichScreen=0;[c,maxElements]=computer;maxSize=floor(sqrt(maxElements));fprintf('Testing: ...\n');errors=0;pix=SCREEN(whichScreen,'PixelSizes');for pixelSize=pix	fprintf('%2d pixelSize\n',pixelSize);	w=SCREEN(whichScreen,'OpenWindow',[],[],pixelSize);	black=BlackIndex(w);	white=WhiteIndex(w);		% Create a sinusoidal image in a MATLAB matrix, in two steps. First	% create a sinusoidal vector, then replicate this vector to produce a	% sinusoidal image. The replication is done by an outer product. This is	% easy to read, though not the fastest way to do it.		nPixels = min(256,maxSize);	cyclesPerImage = 4;	vector = (1+sin(2*pi*cyclesPerImage*(1:nPixels)/nPixels))/2;	image1 = ones(nPixels,1)*(black+(white-black)*vector);	vector = (1-sin(2*pi*cyclesPerImage*(1:nPixels)/nPixels))/2;	image2 = ones(nPixels,1)*(black+(white-black)*vector);	r=round(image1);	g=round(image2);	b=zeros(size(image1));	clear image1 image2		% 'PutColorImage' accepts the color image as either as three MxN arrays, 	% or one MxNx3 array. 'PutImage' accepts a color image only as one MxNx3 array.		for isDouble=[1 0]		if isDouble			fprintf('	double array\n');			r = double(r);			g = double(g);			b = double(b);		else			fprintf('	uint8 array\n');			r = uint8(r);			g = uint8(g);			b = uint8(b);		end					fprintf('		luminance grating\n');		rect=[0 0 size(r,2) size(r,1)];		wRect=SCREEN(w,'Rect');		rect=CenterRect(rect,wRect);		if pixelSize>8			SCREEN(w,'PutColorImage',r,r,r);			WaitSecs(0.5);		end		SCREEN(w,'PutImage',r);		WaitSecs(0.5);		if pixelSize>8			rrr=cat(3,r,r,r);	% NxMx3 array, containing rgb image.		else			rrr=r;		end		rrrCopy=SCREEN(w,'GetImage',rect);		if ~all(double(rrr)==double(rrrCopy))			fprintf('			What PutImage read back differs from what PutImage wrote.\n');			disp('wrote:')			disp(squeeze(rrr(1,1:10,:))')			disp('read:')			disp(squeeze(rrrCopy(1,1:10,:))')			errors=errors+1;		end					if pixelSize>8			fprintf('		red-green grating\n');			rgb=cat(3,r,g,b);	% NxMx3 array, containing rgb image.			SCREEN(w,'PutColorImage',r,g,b);			WaitSecs(0.5);			SCREEN(w,'PutColorImage',rgb);			rgbCopy=SCREEN(w,'GetImage',rect);			if ~all(rgb==rgbCopy)				fprintf('			What PutImage read back differs from what PutColorImage wrote.\n');				disp('wrote:')				disp(squeeze(rgb(1,1:10,:))')				disp('read:')				disp(squeeze(rgbCopy(1,1:10,:))')				errors=errors+1;			end					WaitSecs(0.5);			SCREEN(w,'PutImage',rgb);			rgbCopy=SCREEN(w,'GetImage',rect);			if ~all(rgb==rgbCopy)				fprintf('			What PutImage read back differs from what PutImage wrote.\n');				disp('wrote:')				disp(squeeze(rgb(1,1:10,:))')				disp('read:')				disp(squeeze(rgbCopy(1,1:10,:))')				errors=errors+1;			end					WaitSecs(0.5);		end	end	SCREEN(w,'Close');endfprintf('Done. Every image displayed was read back by ''PutImage'', with %d errors.\n', errors);