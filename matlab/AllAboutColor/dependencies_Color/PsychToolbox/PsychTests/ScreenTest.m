function ScreenTest% ScreenTest tests your computer's ability to show movies on each of your% screens. It times the processor and each video screen, documenting the% characteristics relevant to its use in vision experiments. This is similar% to what is provided by running the VideoToolbox TimeVideo application.% Indeed, much of the underlying C code is shared. Let us know if there's% some other measurement that we should add here.% % (BEGINNERS: ScreenTest will report some important facts about your% computer, but if you're looking for a helpful example while writing your% first movie program, look at MovieDemo and MovieDemo2. ScreenTest.m is% good code, but it's optimized for performance, not readability, and would% be more relevant to consult later, when you're optimizing your own working% code.)% % To rate your computer, the most useful numbers are the number of floating% point operations per second, Mflop/s, (measured for FFT2 of a 32x32% matrix), which characterizes how fast you can process images, and the% unsynchronized CopyWindow rate, in MB/s, which characterizes how fast you% can move pixels onto the screen. The two rates depend on different aspects% of your computer's design. Mflop/s is determined primarily by the% processor clock rate, except that the G4 does nearly twice as many flops% per clock cycle as all the preceding PowerPC chips (601, 603, and G3). MB/s% is determined primarily by the clock rate of the bus that holds the video% card. On most Macs, the internal memory bus (used by built-in video) is% nearly twice as fast as the external bus (NuBus or PCI) that any% additional video cards are plugged into.% % BLANKING. Each video frame ends with blanking (black), caused by a pulse,% sent from your computer's video card to your monitor. (Apple calls it% "VBL", Vertical Blanking Level.) All frame counting and synchronization is% done by reference to the beginning of blanking. The SCREEN PeekBlanking% function tells you exactly when the last blanking interrupt occurred.% (There may be some latency between the blanking and the servicing of the% blanking interrupt, if another interrupt is being serviced at the time of% the blanking pulse).% % RUSH.mex is used to minimize interruption of time-critical code. See Rush,% Priority, RushTest, LoopTest.% % COPYWINDOW (CopyBits) RATE: how fast CopyWindow can pump pixels, in MB/s.% This depends mainly on the speed of the relevant bus: the memory bus for% built-in video or the peripheral bus (PCI or NuBus) for a video card. The% peripheral bus is half as fast as the memory bus on every Macintosh on% which I've been able to make the comparison, so you're better off using% built-in video rather than buying a video card. (A few Macs, e.g. the% PowerMac 9500 and 9600, have no built-in video.)% % WINDOW ALIGNMENT: Highest copying speed is achieved when the processor can% copy 32 bits at a time, and those bits are at 32-bit address boundaries.% OpenOffscreenWindow automatically creates a pixmap that is appropriately% aligned with the window/device that you supply for fast copying of the% whole offscreen window. However, if you CopyWindow only a rect's worth,% then for optimal speed the left and right boundaries of the rect should% correspond to multiples of 32 bits. This only matters if you're optimizing% speed.% % TEARING: You may have seen "tearing" in the movie. The tear is a% horizontal break, perhaps halfway down the screen, jiggling up and down as% the movie played. This tear is normal and does not indicate anything wrong% with your computer or the display software. Tearing can occur in any% display that isn't double buffered, and hardly any of the drivers for% Macintosh video cards support double buffering. Even so, it's easy to% avoid tearing once you understand why it happens. See MovieTearDemo% 6/11/94	dhb	Wrote TimeBlankingTest.% 3/16/97	dgp	Wrote ScreenTimeDemo, based on TimeBlankingTest.% 3/20/97	dgp	Update frameRate measurement to use new PeekBlanking.% 3/21/97	dgp	Measure max synchronized data rate.% 3/27/97	dgp	Never use empty rect. Reduce image height by 10% each time.% 3/27/97	dgp Correct centering.% 3/27/97	dgp Add explanation of "unsynchronized" and "synchronized".% 4/4/97	dgp Polish explanation of "unsynchronized" and "synchronized". Print it first.%				Use bisection rule to home in on size of largest possible real-time movie.%				Make real-time movie square, if possible.%				To save time, use full-screen windows and merely adjust the size of the rect we copy.% 4/11/97	dgp PatchTrap('GetMenuBar',10000);% 4/11/97	dgp Variable name conflicted with built-in function. Rename version to driverVersion.% 4/17/97	dgp Priority(0) before fprintf. This seems to prevent crashes, but I don't know%				if it's actually necessary.% 4/29/97	dgp All calls to Priority() have been removed. We only use Rush().% 6/1/97	dgp Renamed ScreenTest.% 6/3/97	dgp Cleaned up the print out. Fixed bug in bisection search.% 6/4/97	dgp	Faster transfer of grating into offscreen window.% 6/7/97	dgp	Cosmetic.% 8/2/97	dgp	Cosmetic.% 8/16/97	dgp	changed "text" to "theText" to avoid conflict with TEXT function.% 1/12/98	dgp Changed "computerName" to "model". Added FlopPerSec. Tightened up the printout.%				Added explanation, above, of Mflop/s and MB/s.%				Enhanced printout of error conditions. Added "emulating" from new SCREEN.mex.% 1/14/98	dgp Tightened up the priorityLevel printout. Report the WaitForVBLInterrupt pref.% 2/1/98	dgp Leave FileSharing alone. I suspect that it doesn't affect RUSHed code.% 2/16/98	dgp	Moved most of the tearing explanation to MovieTearingDemo.m.% 3/2/98	dgp	Updated for char type of driverVersion returned by SCREEN 'VideoCard'.% 3/2/98	dgp	Supply screenNumber (instead of 0) to MaxPriority.% 3/13/98	dgp	Report new MaxPriorityForBlankingInterrupt.% 3/14/98	dgp	Use FrameRate.m. % 3/14/98	dgp	Remove FileSharing tests, since I doubt FileSharing affects Rushed code.% 3/23/98	dgp	Report QuickTime.% 7/10/98	dgp	Report FileSharing since it affects MFlops.% 7/14/98	dgp	Use new FrameRate and SetBlankingPrefs. % 7/14/98	dgp	Restrict movies on very large screens to reasonable size.% 7/15/98	dgp Polished.% 7/15/98	dgp Test all pixelSizes and print results in table, similar to the TimeVideo application%				in the VideoToolbox.% 7/21/98	dgp	Set GammaIdentity before testing SetClut vs. GetClut.% 7/25/98	dgp	Updated to work with new prefs.% 5/19/99	dgp	Report value of SetClutDriverWaitsForBlanking as "Yes" or "No".% 9/18/99	dgp	Improved algorithm for calculating how long SetClut suppresses interrupts, % 				to fix bug reported by Bob Dougherty.%				Warn when SetClut takes more than one frame.% 9/20/99	dgp	Added missing brackets to line 295, as suggested by Bob Dougherty.% 10/3/99	dgp	Removed call to AfterDark, now obsolete.% 10/3/99	dgp	Updated to use new DriverTest.m instead of old FrameRate.m% 10/5/99	dgp	Made printout more compact, suppressing SetClutDriverAwaitsBlanking %               unless it's inconsistent with SetClutDriverWaitsForBlanking.% 10/28/99  dgp Cosmetic changes to accomodate the 6100.% 11/1/99	dgp Report the new Preferences added to work around the bug in the Rage128 video driver.% 2/15/00	dgp Cosmetic changes to reduce width, to pass through email without wrapping. % 				Email from keith schneider broke lines exceeding 74 characters.% 6/21/00	dgp Test SCREEN Preference AskSetClutDriverToWaitForBlanking.SCREEN('CloseAll'); % start freshif 0	% Pretend we have a Rage128 video driver.	SCREEN(0,'Preference','DipPriorityAfterSetClut',1);	SCREEN(0,'Preference','MinimumSetClutPriority',2);end% if these 3 statements are on, then MATLAB crashes sometime after running ScreenTest on PowerBook Series G3/250.% screen(0,'openwindow',[],[0 0 20 20]); % screen(0,'preference','waitblankingalwayscallssetclut',1);% waitblankingalwayscallssetclut=screen(0,'preference','waitblankingalwayscallssetclut')fprintf('ScreenTest will now test your computer''s ability to show movies on each of\n')fprintf('your screens. For explanation, type:	help screentest\n')% Describe the computerDescribeComputer;% Test every screenfor screenNumber=SCREEN('Screens')	% Describe video card	DescribeScreen(screenNumber);		% Yay! SCREEN Preference AskSetClutDriverToWaitForBlanking set 0 ok, set 1 ok.	oldWarning=warning;	warning off	waitForBlanking=screen(screenNumber,'preference','AskSetClutDriverToWaitForBlanking');	if ~isempty(waitForBlanking)		fprintf('Yay! SCREEN Preference AskSetClutDriverToWaitForBlanking ');		punct=', ';		for setWait=0:1			screen(screenNumber,'preference','AskSetClutDriverToWaitForBlanking',setWait);			getWait=screen(screenNumber,'preference','AskSetClutDriverToWaitForBlanking');			actualWait=screen(screenNumber,'preference','SetClutDriverWaitsForBlanking');			if setWait==getWait & setWait==actualWait				fprintf('set %d ok%s',setWait,punct);			else				fprintf('set %d failed (get %d,actual %d)%s',setWait,getWait,actualWait,punct);			end			punct='.';		end		fprintf('\n');	end	warning(oldWarning);		% WARNING: ScreenTest: WaitBlankingAlwaysCallsSetClut is on, yet SetClutDriverWaitsForBlanking is off.	if SCREEN(screenNumber,'Preference','WaitBlankingAlwaysCallsSetClut') & ~SCREEN(screenNumber,'Preference','SetClutDriverWaitsForBlanking')		fprintf('WARNING: ScreenTest: WaitBlankingAlwaysCallsSetClut is on, yet SetClutDriverWaitsForBlanking is off.\n');	end	% Report preferences that work around the Rage128 driver bug.	if SCREEN(screenNumber,'Preference','DipPriorityAfterSetClut')		fprintf('NOTE: DipPriorityAfterSetClut is true. Works around Rage128 driver bug.\n');	end	if SCREEN(screenNumber,'Preference','MinimumSetClutPriority')		fprintf('NOTE: MinimumSetClutPriority is %d. Works around Rage128 driver bug.\n',SCREEN(screenNumber,'Preference','MinimumSetClutPriority'));	end	[oldPixelSize,oldIsColor]=SCREEN(screenNumber,'PixelSize');	pixelSizes=SCREEN(screenNumber,'PixelSizes');	for ii=1:length(pixelSizes)		SCREEN(screenNumber,'PixelSize',pixelSizes(ii),1);				% blanking: DriverTest		vTemp=DriverTest(screenNumber);			% pages, pixelSize		[vTemp.pixelSize,vTemp.isColor,vTemp.pages]=SCREEN(screenNumber,'PixelSize');				% GetClut		oldClut=ClutDefault(screenNumber);		if isempty(SCREEN(screenNumber,'GetClut'));			vTemp.getClut=-1; % GetClut not available.		else			newClut=Shuffle(oldClut);			SCREEN(screenNumber,'Gamma',GammaIdentity(screenNumber));			SCREEN(screenNumber,'SetClut',newClut);			testClut=SCREEN(screenNumber,'GetClut');			vTemp.getClut=all(all(testClut==newClut));			SCREEN(screenNumber,'SetClut',oldClut);		end		vTemp.maxPriorityForBlankingInterrupt=SCREEN(screenNumber,'Preference','MaxPriorityForBlankingInterrupt');		% suppresses interrupts		s=0;j=0;k=0;f0=0;s0=0;f=0;s=0;reps=10;SCREEN('Screens'); % Make sure all rushed functions are in memory.		priorityLevel=MaxPriority(screenNumber,'PeekBlanking','GetSecs');		loop={			'for k=1;'				'SCREEN(screenNumber,''SetClut'',oldClut);'				'[f0,s0]=SCREEN(screenNumber,''PeekBlanking'');'				'for j=1:reps;'					'SCREEN(screenNumber,''SetClut'',oldClut);'				'end;'				'[f,s]=SCREEN(screenNumber,''PeekBlanking'');'			'end;'		};  		oldSetClutPunches=SCREEN(screenNumber,'Preference','SetClutPunchesBlankingClock',0);		Rush(loop,priorityLevel);  		SCREEN(screenNumber,'Preference','SetClutPunchesBlankingClock',oldSetClutPunches);		f=f-f0; s=s-s0;		vTemp.suppresses=(s*FrameRate(screenNumber)-f)/reps;		vTemp.suppresses=vTemp.suppresses+0.004; % this tiny positive fudge helps to make the answer positive		% CopyWindow		% create one onscreen window, and a bunch of offscreen windows		pixelSize=SCREEN(screenNumber,'PixelSize');		r=SCREEN(screenNumber,'Rect');		b=RectWidth(r)*RectHeight(r)*pixelSize/8;		bMax=(bytes('Free')+bytes('TempFree')-1e6)/8;		bMax=min([1e6 bMax]);		bMax=max([bMax 0]);		if b>bMax			r=AlignAndCenter(screenNumber,r*sqrt(bMax/b));		end		w=SCREEN(screenNumber,'OpenWindow',[],r);		theText=str2mat('Now computing an 8-frame movie,','to be shown asynchronously.');		SCREEN(w,'TextFont','Chicago');		SCREEN(w,'TextSize',18);		textWidth=SCREEN(w,'TextWidth',theText(1,:));		textHeight=size(theText,1)*SCREEN(w,'TextWidth','x');		textRect=CenterRect([0,0,textWidth,3*textHeight],SCREEN(w,'Rect'));		for i=1:size(theText,1)			SCREEN(w,'DrawText',theText(i,:),textRect(RectLeft),textRect(RectTop)+i*textHeight,-1);		end		% 'PutImage' could expand our one-line grating to fill the image,		% but it's slow. Straight copying (replication) is the fastest operation, 		% so, instead, we ask 'CopyWindow' to expand to 1/4 height of image,		% and then replicate twice to fill the whole image.		rect=OffsetRect(r,-r(RectLeft),-r(RectTop));		lineRect=rect;		lineRect(RectBottom)=lineRect(RectTop)+1;		r1=rect;		r1(RectBottom)=rect(RectTop)+ceil(RectHeight(rect)/4);		r2=OffsetRect(r1,0,RectHeight(r1));		r3=rect;		r3(RectBottom)=rect(RectTop)+ceil(RectHeight(rect)/2);		r4=OffsetRect(r3,0,RectHeight(r3));		white=WhiteIndex(screenNumber);		black=BlackIndex(screenNumber);		for i=1:8			o(i)=SCREEN(w,'OpenOffscreenWindow');			grating=1:RectWidth(rect);			grating=i/8+3*grating/RectWidth(rect);			grating=(1+sin(2*pi*grating))/2;	% range 0 to 1.			grating=black+(white-black)*grating;			SCREEN(o(i),'PutImage',grating,lineRect);			SCREEN('CopyWindow',o(i),o(i),lineRect,r1);			SCREEN('CopyWindow',o(i),o(i),r1,r2);			SCREEN('CopyWindow',o(i),o(i),r3,r4);		end				% CopyWindow rate, asynchronous		% Make sure all Rushed functions are in memory.		s=0;j=0;k=0;rem(1,1);reps=30;GetSecs;SCREEN('Screens');		priorityLevel=MaxPriority('GetSecs');		loop={			'for k=1;'				's=GetSecs;'				'for j=1:reps;'					'SCREEN(''CopyWindow'',o(1+rem(j,8)),w);'				'end;'				's=GetSecs-s;'			'end;'		};		Rush(loop,priorityLevel);		bytesCopied=reps*RectWidth(r)*RectHeight(r)*pixelSize/8;		vTemp.copyWindow=bytesCopied/s;		SCREEN(w,'Close');		for i=1:length(o)			SCREEN(o(i),'Close');		end		v(ii)=vTemp;	end	fprintf('pixel size                     ');	fprintf('%6d',v(:).pixelSize);	fprintf('     bits\n');	fprintf('pages                          ');	fprintf('%6d',v(:).pages);	fprintf('\n');	fprintf('CopyWindow (ie CopyBits)       ');	switch floor(log10(min([v(:).copyWindow]/1e6)))		case {4,3,2,1,0}, fprintf('%6.0f',[v(:).copyWindow]/1e6); fprintf('   ');		case -1, fprintf('  ');fprintf('%6.1f',[v(:).copyWindow]/1e6); fprintf(' ');		otherwise, fprintf('   ');fprintf('%6.2f',[v(:).copyWindow]/1e6); fprintf('');	end	fprintf('  MB/s\n');	fprintf('GetClut equals SetClut?          ');	for i=1:length(pixelSizes);		switch v(i).getClut			case 1, fprintf('   == '); % GetClut==SetClut			case 0, fprintf('   ~= '); % GetClut~=SetClut			case -1,fprintf('   na '); % GetClut not available.		end	end	if any([v.getClut]==-1)		%fprintf('   Not available.');	end	fprintf('\n');	fprintf('SetClutDriverWaitsForBlanking?   ');	for i=1:length(pixelSizes)		fprintf('      ');	end	if SCREEN(screenNumber,'Preference','SetClutDriverWaitsForBlanking')		fprintf('   Yes\n');	else		fprintf('   No\n');	end		if v(1).priority>v(1).priorityLow		% at high priority		fprintf('At priority %3g ...              ',v(1).priority);		for i=1:length(pixelSizes)			fprintf('      ');		end		if v(1).priority>MaxPriority(v(1).windowPtrOrScreenNumber,'BlankingInterrupt')			fprintf('   No blanking intrpts.\n');		else			fprintf('   Blanking interrupts.\n');		end		fprintf('SetClut (cscSetEntries) min dur. ');		fprintf('%6.1f',v(:).setClutFraction);		fprintf('   frames\n');		if isempty(v(1).setClutDriverAwaitsBlanking) | ~(v(1).setClutDriverAwaitsBlanking==SCREEN(screenNumber,'Preference','SetClutDriverWaitsForBlanking'))			fprintf('*** SetClutDriverAwaitsBlanking? ');			for i=1:length(pixelSizes)				fprintf('      ');			end			if v(1).setClutDriverAwaitsBlanking				fprintf('   Yes\n');			else				if isempty(v(1).setClutDriverAwaitsBlanking)					fprintf('   ?\n');				else					fprintf('   No\n');				end			end		end	% 	fprintf('MaxPriorityForBlankingInterrupt');	% 	fprintf('%6d',v(:).maxPriorityForBlankingInterrupt);	% 	fprintf('\n');		if any([v(:).setClutFraction]>1.01)			fprintf('WARNING: min duration exceeds a frame. You can''t load a new CLUT on every frame.\n');		end	end	% at low priority	fprintf('At priority %3g ...              ',v(1).priorityLow);	for i=1:length(pixelSizes)		fprintf('      ');	end	if v(1).priorityLow>MaxPriority(v(1).windowPtrOrScreenNumber,'BlankingInterrupt')		fprintf('   No blanking intrpts.\n');	else		fprintf('   Blanking interrupts.\n');	end	fprintf('SetClut (cscSetEntries) min dur. ');	fprintf('%6.1f',v(:).setClutFractionLow);	fprintf('   frames\n');	fprintf('SetClut suppresses ints. for     ');	fprintf('%6.1f',v(:).suppresses);	fprintf('   frames\n');	if isempty(v(1).setClutDriverAwaitsBlankingLow) | ~(v(1).setClutDriverAwaitsBlankingLow==SCREEN(screenNumber,'Preference','SetClutDriverWaitsForBlanking'))		fprintf('*** SetClutDriverAwaitsBlanking? ');		for i=1:length(pixelSizes)			fprintf('      ');		end		if v(1).setClutDriverAwaitsBlankingLow			fprintf('   Yes\n');		else			if isempty(v(1).setClutDriverAwaitsBlankingLow)				fprintf('   ?\n');			else				fprintf('   No\n');			end		end	end% 	fprintf('MaxPriorityForBlankingInterrupt');% 	fprintf('%6d',v(:).maxPriorityForBlankingInterrupt);% 	fprintf('\n');	if any([v(:).setClutFractionLow]>1.01)		fprintf('WARNING: min duration exceeds a frame. You can''t load a new CLUT on every frame.\n');	endendDescribeScreen(-1); % end of tablereturnfunction r=FlopPerSec	% r=FlopPerSec	% Measure flop/s for FFT2. The ops increase as n*n*log(n). We first do n=8.	% If the machine is fast (i.e. not using SoftwareFPU) then we do n=32, which	% yields ratings similar to what we'd get for doing n=256, a typical	% image width.	r=fps(8);	if r>10000		% use bigger matrix if machine is fast		r=fps(32);	endreturnfunction r=fps(n)	f=flops;t=getsecs;fft2(1);	% load functions into memory	x=magic(n);	for i=1 % precompile		f=flops;		t=getsecs;		fft2(x);		t=getsecs-t;		f=flops-f;	end	r=f/t;returnfunction rNew=AlignAndCenter(w,r)	screenNumber=SCREEN(w,'WindowScreenNumber');	screenRect=SCREEN(screenNumber,'Rect');	r=CenterRect(r,screenRect);	pixelSize=SCREEN(w,'PixelSize');	r([RectLeft RectRight])=round(r([RectLeft RectRight])*pixelSize/32)*32/pixelSize;	rNew=r;return;