% CalibrateMonDrvr%% Main script for monitor calibration.  May be called% once parameters are set up.%% Each monitor input channel is calibrated.% A summary spectrum is computed.% Gamma curves are computed.%% Saves output in specified file.%% 10/26/93	dhb		Wrote it based on CalibrateProj.% 11/3/93		dhb		Added filename entry with default.% 2/28/94		dhb		Updated SetMon call to SetColor call.% 3/12/94		dhb		Created version for monitor 0.% 								User interface is a little wild.% 4/3/94		dhb		Save the darkAmbient variable.% 								User interface improvements% 9/4/94		dhb		Incorporate gamma fitting%									improvements from CalibrateMonRoom.%						dhb		Add whichScreen variable. %						dhb		Add sync mode variable.%	10/20/94	dhb		Add bgColor variable.% 11/18/94  ccc   Change the range of LUT from (0,255) to %                 (0, InputLevels-step) with step=nInputLevels/255 % 11/21/94	dhb, ccc	Further nine-bit modifications.% 1/23/95		dhb		Pulled parameter setting out into a calling script,%									made user prompting conditional.% 4/12/97		dhb		Update for new toolbox.% 8/21/97		dhb		Don't save data here.% 					dhb		Get rid of option not to measure.% 4/7/99    dhb   NINEBIT -> NBITS.%           dhb   Handle noMeterAvail, RADIUS switches.%           dhb   Check for empty indexLin.% 9/22/99   dhb, mdr  Make boxRect depend on boxSize, defined up one level.% 10/1/99   dhb, mdr  Pull out nMonBases, defined up one level.% 12/2/99   dhb   Put background on after white box for aiming.% Measurement parametersmonWls = SToWls(S);% Define device characteristicsbits = NBITS;nInputLevels = 2^bits;% Define input settings for the measurementsmGammaInputRaw = round(linspace(nInputLevels/nMeas,nInputLevels-1,nMeas))';% Get user to do his thingif (USERPROMPT == 1)	disp(' ');	disp('Make sure to turn room lights off!');	disp('The screen will present a box');  disp('Focus radiometer on the displayed square');	disp('then hit any key when you are ready to go');	disp(sprintf('You will get %g seconds after that to leave the room',leaveRoomTime));	disp('Hit any key to proceed past this message');	GetChar;end% Blank the screenif (RADIUS)	[window,screenRect] = SCREEN(whichScreen,'OpenWindow',0,[],32);else	[window,screenRect] = SCREEN(whichScreen,'OpenWindow',0);endif (whichScreen == 0)	HideCursor;endif (RADIUS)	radiusGamma = (0:4:1020)'*ones(1,3);	SCREEN(window,'Gamma',radiusGamma,10);	SCREEN(window,'SetClut',(0:255)'*ones(1,3));end% Draw a box in the center of the screenboxRect = [0 0 boxSize boxSize];boxRect = CenterRect(boxRect,screenRect);SCREEN(window,'FillRect',1,boxRect);if (RADIUS)	radiusGamma(1,:) = [nInputLevels-1 nInputLevels-1 nInputLevels-1];	SCREEN(window,'WaitBlanking');	SCREEN(window,'Gamma',radiusGamma,10);else	SetColor(window,1,[nInputLevels-1 nInputLevels-1 nInputLevels-1]',bits);end% Wait for userif (USERPROMPT == 1)  GetChar;	WaitTicks(60*leaveRoomTime);end% Put correct surround for measurements.if (RADIUS)	radiusGamma(1,:) = cal.bgColor';	SCREEN(window,'WaitBlanking');	SCREEN(window,'Gamma',radiusGamma,10);else  SetColor(window,0,cal.bgColor,bits);end% Get synchronization timingif (syncMode ~= 0)	freq = CMETER('Frequency');	if (freq ~= -1)		disp(sprintf('Using frequency of %g Hz',freq));	else		disp('Cannot sync, using DC mode');		syncMode = 0;	endend% Start timingt0 = clock;% SCREEN('MATLABToFront');mon = zeros(S(3)*nMeas,nMonDevices);for a = 1:nAverage  for i = 1:nMonDevices    disp(sprintf('Monitor device %g',i));		SCREEN(window,'FillRect',1,boxRect);		    % Measure ambient		darkAmbient1 = MeasMonSpd(window,[0 0 0]',S,0,bits,noMeterAvail,RADIUS);    % Measure full gamma in random order    mGammaInput = zeros(nMonDevices,nMeas);    mGammaInput(i,:) = mGammaInputRaw';    sortVals = rand(nMeas,1);    [null,sortIndex] = sort(sortVals);		%fprintf(1,'MeasMonSpd run %g, device %g\n',a,i);		[tempMon,S] = MeasMonSpd(window,mGammaInput(:,sortIndex),S,syncMode,bits,noMeterAvail,RADIUS);      tempMon(:,sortIndex) = tempMon;    % Take another ambient reading and average		darkAmbient2 = MeasMonSpd(window,[0 0 0]',S,0,bits,noMeterAvail,RADIUS);      darkAmbient = ((darkAmbient1+darkAmbient2)/2)*ones(1,nMeas);    % Subtract ambient    tempMon = tempMon - darkAmbient;    % Store data    mon(:,i) = mon(:,i) + reshape(tempMon,S(3)*nMeas,1);  endendmon = mon / nAverage;% Close the screenSCREEN(window,'Close');ShowCursor;% Report timet1 = clock;disp(sprintf('CalibrateMonDrv measurements took %g minutes',etime(t1,t0)/60));% Pre-process data to get rid of negative values.mon = EnforcePos(mon);% Use data to compute best spectra according to desired% linear model.  We use SVD to find the best linear model,% then scale to best approximate maximumdisp('Computing linear models');Pmon = zeros(S(3),nMonDevices*nMonBases);mGammaRaw = zeros(nMeas,nMonDevices*nMonBases);monSVs = zeros(nMeas,nMonDevices);for i = 1:nMonDevices  tempMon = reshape(mon(:,i),S(3),nMeas);  monSVs(:,i) = svd(tempMon);  [monB,monW] = FindLinMod(tempMon,nMonBases);  for j = 1:nMonBases    monB(:,j) = monB(:,j)*monW(j,nMeas);  end  monW = FindModelWeights(tempMon,monB);  for j = 1:nMonBases    mGammaRaw(:,i+(j-1)*nMonDevices) = (monW(j,:))';    Pmon(:,i+(j-1)*nMonDevices) = monB(:,j);  end  plot(monWls,tempMon,'+');  hold on  plot(monWls,(monB*monW));  hold offend% Put up a plothold offplot(Pmon);% Fit gamma functions.  For fitting, we set to zero the raw data we% believe to be below reliable measurement threshold (contrastThresh).% Currently we are fitting both with polynomial and a linear interpolation,% using the latter for low measurement values.  The fit break point is% given by fitBreakThresh.   This technique was developed% through bitter experience and is not theoretically driven.mGammaMassaged = mGammaRaw(:,1:nMonDevices);massIndex = find(mGammaMassaged < contrastThresh);mGammaMassaged(massIndex) = zeros(length(massIndex),1);for i = 1:nMonDevices	mGammaMassaged(:,i) = MakeMonotonic(HalfRect(mGammaMassaged(:,i)));endfitType = 7;[mGammaFit1a,mGammaInputFit,mGammaCommenta] = FitDeviceGamma(...  mGammaMassaged,mGammaInputRaw,fitType);fitType = 6;[mGammaFit1b,mGammaInputFit,mGammaCommentb] = FitDeviceGamma(...  mGammaMassaged,mGammaInputRaw,fitType);mGammaFit1 = mGammaFit1a;for i = 1:nMonDevices	indexLin = find(mGammaMassaged(:,i) < fitBreakThresh);	if (~isempty(indexLin))		breakIndex = max(indexLin);		breakInput = mGammaInputRaw(breakIndex);		inputIndex = find(mGammaInputFit <= breakInput);		if (~isempty(inputIndex)) 			mGammaFit1(inputIndex,i) = mGammaFit1b(inputIndex,i);		end	endend% Higher order components do not have this constraint and are fit with% a brute force homogeneous polynomial.if (nMonBases > 1)  [m,n] = size(mGammaFit1);  mGammaFit2 = zeros(m,nMonDevices*(nMonBases-1));  for j = 1:nMonDevices*(nMonBases-1)    mGammaFit2(:,j) = ...      FitGammaPolyR(mGammaInputRaw,mGammaRaw(:,nMonDevices+j), ...      mGammaInputFit);  end  mGammaFit = [mGammaFit1 , mGammaFit2];else  mGammaFit = mGammaFit1;end% Put up a plotplot(mGammaInputFit,mGammaFit);hold onplot(mGammaInputRaw,mGammaRaw,'+');hold off% Save information in form for calibration routinesSmon = S;Tmon = WlsToT(Smon);         