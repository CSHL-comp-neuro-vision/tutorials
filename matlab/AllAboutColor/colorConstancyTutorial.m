%% colorConstancyTutorial%% This tutorial will take you through a simple simulation of a color% constancy algorithm.  The algorithm is based on linear model constraints% and the gray world assumption. This algorithm is due to Buchsbaum.%% See also: colorRenderingTutorial, colorSpaceTutorial%% This tutorial will make more sense to you if you go through % colorRenderingTutorial first, which introduces many ideas relevant here.%% Dependencies:%               a) Psychophysics Toolbox:PsychColorimetricData %               b) colorFunctions subfolder%addpath('PsychToolbox')%addpath('PsychColorimetric');%addpath('PsychColorimetricData');%addpath('colorConstancyTutorial');% -- should be taken care of now when dependencies are loaded below% 06/18/02  dhb  Wrote it.% 06/27/22  eac   A little clean up of dependenciesaddpath(genpath('dependencies_Color'));% % Initialize%clear allclose all%%% % Read in a large set of surface reflectance functions These are the% spectra of the Munsell papers and were measured by Nickerson.%% We compute a linear model for this set of surfaces, using methods% introduced in colorRenderingTutorial.  Then using the linear model, we% find the surface weights and various statistics of these weights.  We'll% characterize the weights using a multivariate normal.%% We'll spline all spectral functions to the range 400-700 nm at 5 nm% intervals.nBases = 3;load sur_nickersonS = [400 5 61];sur_nickerson = SplineSrf(S_nickerson,sur_nickerson,S);wls = SToWls(S);nNickerson = size(sur_nickerson,2);[u,d,v] = svd(sur_nickerson);Bsur = u(:,1:nBases);wgts_nickerson = Bsur\sur_nickerson;populationMeanSurface = mean(sur_nickerson,2);%%%% Load in a linear model for lights.  Here we don't have an actual dataset% to fit, but we can use the published CIE linear model for daylights.%% Using this model, we can generate 'typical' daylight spectra by% specifying a color temperature.  We'll generate rather bluish daylight.% The routine GenerateCIEDay constructs an illuminant with the CIE linear% model for daylight, so we're sure that the illuminant satisfies the three% dimensional linear model consraint.  The parameter colorTemp controls the% chromaticity of the illuminant within the linear model. Reasonable values% for colorTemp are in the range 4000-10000.load B_cieday;Billum = SplineSpd(S_cieday,B_cieday,S);colorTemp = 10000;theIllum = GenerateCIEDay(colorTemp,Billum);%%% % Read in estimates of the human cone spectral sensitivities.%% The sensitivities we load are the Smith-Pokorny estimates.  These are% derived from the Judd-Vos modified XYZ color matching functions. Each% cone sensitivity is normalized to a maximum of 1.load T_cones_spT_cones = SplineCmf(S_cones_sp,T_cones_sp,S);% Simulate image formation, using a random draw from the nickeson surfaces.% This procedure guarantees that the surfaces nSurfaces = 10;surfaceIndices = Ranint(nSurfaces,nNickerson);theSurfaces = sur_nickerson(:,surfaceIndices);theConeResponses = T_cones*diag(theIllum)*theSurfaces;%% % Use Buchsbaum's gray world algorithm to estimate the illuminant.  We% assume three dimensional linear models for illuminants and surfaces, and% that the mean surface in the population is known.%% Plot actual (simulated) illuminant in red, estimate in green. The% estimate should be reasonable but not perfect.theMeanConeRespones = mean(theConeResponses,2);illumWgtsEstimate1 = inv(T_cones*diag(populationMeanSurface)*Billum)*theMeanConeRespones;illumEstimate1 = Billum*illumWgtsEstimate1;figure(1); clf; hold onplot(wls,theIllum,'r');plot(wls,illumEstimate1,'g');%%% % Given the illuminant estimate, reconstruct the surfaces. Plot true% surfaces in red, estimates in green.  The plot is a little messy but% you'll get the sense that the surface estimates deviate from the truth in% a manner roughly commensurate with the illuminant estimation error.surWgtsEstimate1 = inv(T_cones*diag(illumEstimate1)*Bsur)*theConeResponses;surEstimates1 = Bsur*surWgtsEstimate1;figure(2); clf; hold onplot(wls,theSurfaces,'r');plot(wls,surEstimates1,'g');% You'll see some error in the estimates.  There are two possible sources% for this error.  One is that the surfaces are not perfectly described by% the three dimensional linear model that the algorithm assumes.  The other% is that the mean of the surfaces in the simulated image deviates from the% population mean assumed by the algorithm.  we can test both possiblities.% We'll just do this for the illuminant estimates, not for the surfaces.%%% First let's force the surfaces to lie within the linear model and see% what happens, when we keep all else the same.  We'll add this estimate to% our plot in blue.  The blue and green curves are very close, indicating% that linear model violations are a small part of the problem.modelSurfaces = Bsur*(Bsur\theSurfaces);modelConeResponses = T_cones*diag(theIllum)*modelSurfaces;modelMeanConeRespones = mean(modelConeResponses,2);illumWgtsEstimate2 = inv(T_cones*diag(populationMeanSurface)*Billum)*modelMeanConeRespones;illumEstimate2 = Billum*illumWgtsEstimate2;figure(1);plot(wls,illumEstimate2,'b');%%% Second, let's give the algorithm access the the mean of the surfaces% actually in the image.  This is a cheat from the point of view of a real% algorithm but will verify that it's deviations of the sample and% population means that drive the error.%% We'll plot the result here in black.  Now the estimate is spot on, since% now the imaging model corresponds to the algorithm assumptions.sampleMeanSurface = mean(modelSurfaces,2);illumWgtsEstimate3 = inv(T_cones*diag(sampleMeanSurface)*Billum)*modelMeanConeRespones;illumEstimate3 = Billum*illumWgtsEstimate3;figure(1);plot(wls,illumEstimate3,'k');%%% % There are two simple extensions to this tutorial that might be fun.%  a) Put a loop around the basic estimation simulation and get a sense for%  the variability of the estimates when you repeat with the same number of%  simulated surfaces.%%  b) Put a loop around a) and investigate the effect of varying the number%  of surfaces on the estimates.  Performance should get better as the%  number of surfaces increases, because the deviations of the sample mean%  from the population means. 