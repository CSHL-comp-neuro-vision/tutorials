%don't ask what this is.  It does not matter.NumIterations = 100;			% number of simulated trialsSegLength = 100;				% number of time points in each rod responseRodPoolDimension = 12;			% simulated rod array is square with this many rods along one sideMeanPhosA = 0.02;				% mean number of photons absorbed in first response group ('correct' responses)MeanPhosB = 0.00001;			% mean number of photons absorbed in second response group ('incorrect' responses)FlashTimeA = 1;					% time point in which flash occurs in first response groupFlashTimeB = 1;					% time point in which flash occurs in second response groupshuffles = 5;					% number of shuffles for bootstrap resamplingVerbose = 1;					% prints lots of crap to command windowRFRadius = 4;					% radius of circularly symmetric Gaussian receptive fieldPower = 1;						% parameter of power-law nonlinearity applied to each rod response before poolingkeyboard;RodResponseSignal = SimulateRodArrayResponse(RodPoolDimension, NumIterations, MeanPhosA, SegLength, FlashTimeA);RodResponseNoise = SimulateRodArrayResponse(RodPoolDimension, NumIterations, MeanPhosB, SegLength, FlashTimeB);for XLoc = 1:RodPoolDimension  for YLoc = 1:RodPoolDimension	DistanceToRFCenter = (XLoc - RodPoolDimension/2).^2 + (YLoc - RodPoolDimension/2).^2;	RFWeightMatrix(XLoc, YLoc) = exp(-DistanceToRFCenter / (2 * RFRadius.^2));  endendrespSignal(1:NumIterations,1:SegLength) = 0;respNoise(1:NumIterations,1:SegLength) = 0;for i = 1:NumIterations  for XLoc = 1:RodPoolDimension	for YLoc = 1:RodPoolDimension  	  temp(1:SegLength) = RodResponseSignal(XLoc, YLoc, 1:SegLength, i);	  respSignal(i,1:SegLength) = (respSignal(i,1:SegLength)' + RFWeightMatrix(XLoc, YLoc) * (temp)')';	  temp(1:SegLength) = RodResponseNoise(XLoc, YLoc, 1:SegLength, i);	  respNoise(i,1:SegLength) = (respNoise(i,1:SegLength)' + RFWeightMatrix(XLoc, YLoc) * (temp)')';	end  end  %plot(respSignal(i,:),'k');hold on;plot(respNoise(i,:),'r');endstddev = mean(std(respNoise));