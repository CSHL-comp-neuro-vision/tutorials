% [pop, ind, S, res] = shModelV1Linear(s, pars, resdirs)      get the linear v1 response to a stimulus
%
% M is a 3D movie whose dimensions are [y, x, t]. pars is an SH model
% parameters structure, typically generated by shPars. S is a 4-dimensional
% matrix [y, x, t, n] containing the responses of n separable directional
% derivative filters to the stimulus M. pop is a similarly constructed
% 4-dimensional matrix, but contains the directional derivative responses
% specified in pars.v1PopulationDirections. resdirs is an mx3 matrix specifying m
% additional directions for directional derivative filters; if resdirs is
% specified, res is a 4-dimensional matrix containing the response of these
% filters. If resdirs is not supplied, res = pop.

function varargout = shModelV1Linear(varargin)

% unpack varargin
M = varargin{1};
pars = varargin{2};
v1SpatialFilters = pars.v1SpatialFilters;
v1TemporalFilters = pars.v1TemporalFilters;
v1PopulationDirections = pars.v1PopulationDirections;
nScales = pars.nScales;
if nargin > 2
    resdirs = varargin{3};
end

% make sure the inputs are okay.
mSz = [size(M, 1), size(M, 2), size(M, 3)];
if any(mSz < shGetDims(pars, 'v1lin'))
    error('Stimulus is too small for computation of V1lin stage.');
end

if nargout > 3 && nargin < 3
    error('You must specify which neuronal responses you want.');
end

% Convolve the stimulus with separable linear V1 filters.
order = 3;
fsz = size(v1SpatialFilters, 1);
ind = zeros(nScales+1, 4);
for scale = 1:nScales
    m = blurDn3(M, scale);
    n = 1;
    for torder = 0:order
        tfilt = reshape(flipud(v1TemporalFilters(:,torder+1)),[1 1 fsz]);
        tmp1 = validCorrDn3(m, reshape(tfilt, [1 1 fsz]));  % first conv
        for xorder = 0:(order-torder)
            yorder = order - torder - xorder;
            xfilt = reshape(v1SpatialFilters(:,xorder+1),[1 fsz 1]);
            yfilt = reshape(flipud(v1SpatialFilters(:,yorder+1)),[fsz 1 1]);
            tmp2 = validCorrDn3(validCorrDn3(tmp1, yfilt), xfilt); % second and third convs


            ind(scale+1, 2:4) = [size(tmp2, 1), size(tmp2, 2), size(tmp2, 3)];
            tmp2 = tmp2(:);
            ind(scale+1, 1) = ind(scale, 1) + size(tmp2, 1);
            if ~exist('S', 'var')
                S = zeros(size(tmp2, 1), 10);
            end
            if (size(S,1) ~= ind(scale+1, 1));
                S = [S; zeros(size(tmp2, 1), 10)];
            end
            S(ind(scale, 1)+1:ind(scale+1, 1), n) = tmp2;      % store the result in S
            n = n + 1;
        end
    end
end

% now get the responses of the filters specified in pars.v1PopulationDirections from S by
% interpolation.
pop = S*shSwts(v1PopulationDirections)';                 % interpolate to get pop
pop = pop*pars.scaleFactors.v1Linear;

% if the user requested the responses of filters in extra directions,
% calculate these now and store them in 'res'. If not, then 'res' contains
% pop.

varargout{1} = pop;
varargout{2} = ind;
varargout{3} = S;
if nargout > 3
    res = S*shSwts(resdirs)';
    res = res*pars.scaleFactors.v1Linear;
    varargout{4} = res;
end
