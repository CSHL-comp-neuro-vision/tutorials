% [populationResponse, v1Directions] = shV1PopulationResponse(stimulus, pars,
%                                   stageName, nAngles, whichComponent, nAtATime)
%
% Compute the response of a large population of V1 neurons to a stimulus.
%
% Required arguments:
% stimulus          a 3D matrix that contains a stimulus. Its dimensions
%                   must be [Y X T].
% pars              a parameters structure like the default parameter
%                   structure generated by shPars.
%
% Optional arguments:
% stageName         The stage for which you want the population response. 
%                   DEFAULT = 'v1Complex'.
% nAngles           The number of angles - both azimuthal and elevational -
%                   into which you want to divide the sphere
% whichComponent    For use with looking at the components of the divisive
%                   normalization signal. Choices: 'res', 'nume', 'deno'. 
%                   'nume' and 'deno' only work if stageName = 'v1Complex'.
%                   DEFAULT = 'res'
% nAtATime          the number of responses to compute in each batch. If
%                   this function makes MATLAB run out of memory, reduce
%                   nAtATime. DEFAULT = 1000;
%
% Output:
% populationResponse    a vector containing the average response of each
%                       neuron in the population.
% v1Directions          the tuning parameters of each neuron in the
%                       population, in standard format: the first number is
%                       the preferred direction in radians with 0 = right.
%                       The second number is the preferred ratio of
%                       temporal frequency to spatial frequency, in
%                       cycles/frame and cycles/pixel.
%
% Example of use:
% pars = shPars;
% dims = shGetDims(pars, 'mtPattern', [1 1 101]);
% stimulus = mkDots(dims, 0, 1);
% vels = linspace(-3, 3, 15);
% [populationResponse, v1Directions] = shV1PopulationResponse(stimulus, pars);
% shShowV1PopulationResponse(populationResponse);
% rotate3d on

function [populationResponse, v1Directions] = shv1popres(varargin)

%%%% PARSE ARGUMENTS

stageName = 'default';
nAngles = 'default';
whichComponent = 'default';
nAtATime = 'default';

                        stimulus = varargin{1};
                        pars = varargin{2};
if nargin >= 3;         stageName = varargin{3};            end;
if nargin >= 4;         nAngles = varargin{4};              end;
if nargin >= 5;         whichComponent = varargin{5};       end;
if nargin >= 6;         nAtATime = varargin{6};             end;

if strcmp(stageName, 'default');        stageName = 'v1Complex';        end;
if strcmp(nAngles, 'default');          nAngles = 20;                   end;
if strcmp(whichComponent, 'default');   whichComponent = 'res';         end;
if strcmp(nAtATime, 'default')'         nAtATime = 1000;                end;

%%%% DONE PARSING ARGUMENTS



ntheta = nAngles;
nphi = nAngles;
phi = linspace(-pi/2, pi/2, nphi+1);
theta = linspace(0, 2.*pi, ntheta+1);
v1Directions = [];
for j = 1:nphi
    v1az = [mean(theta(1:2)):theta(2)-theta(1):mean(theta(end-1:end))]';
    v1el = repmat(mean(phi(j:j+1)), size(v1az, 1), 1);
    v1Directions = [v1Directions; [v1az, tan(v1el)]];
end

res = zeros(size(v1Directions, 1), 1);
i = 0;
while i < size(v1Directions, 1)
    startPoint = i+1;
    endPoint = min(i+nAtATime, size(v1Directions, 1));
    v1sThisTime = v1Directions(startPoint:endPoint, :);

    if strcmp(stageName, 'v1complex');
        [pop, ind, res, nume, deno, resnume, resdeno] = shModel(stimulus, pars, stageName, v1sThisTime);
    elseif strcmp(stageName, 'v1simple');
        [pop, ind, res, nume, deno, resnume, resdeno] = shModel(stimulus, pars, stageName, v1sThisTime);
    else
        [pop, ind, res] = shModel(stimulus, pars, stageName, v1sThisTime);
    end

    if strcmp(stageName, 'v1lin')
        res = sqrt(res.^2);
    end

    if strcmp(whichComponent, 'nume')
        populationResponse = mean(shGetNeuron(resnume, ind), 2);
    elseif strcmp(whichComponent, 'deno')
        populationResponse = max(shGetNeuron(resdeno, ind), [], 2);
    else
        populationResponse = mean(shGetNeuron(res, ind), 2);
    end
    
    rAll(startPoint:endPoint, 1) = populationResponse;
    i = i+nAtATime;
end

populationResponse = rAll;