% [pop, ind, res] = shModel(stimulus, pars, stageName, additionalNeurons) Run the Simoncelli & Heeger model.
%
% Required arguments:
% stimulus          a 3D matrix that contains a stimulus. Its dimensions
%                   must be [Y X T].
% pars              a parameters structure like the default parameter
%                   structure generated by shPars.
% stageName         the stage of the model whose output you want computed. 
%                   supported options: 'v1Complex', 'mtPattern'
%
% Optional arguments:
% additionalNeurons     by default the model only computes the responses of
%                       neurons in the population specified by
%                       pars.v1PopulationDirections (for V1 stages) or
%                       pars.mtPopulationVelocities (for MT stages). You
%                       can request that shModel also compute the responses
%                       of additional neurons not in the original
%                       populations by specifying them with this argument.
%                       additionalNeurons is an Mx2 matrix. Each row
%                       specifies the tuning of a different neuron; the
%                       first column specifies the preferred direction,
%                       while the second neuron specifies either the
%                       preferred speed (for MT neurons) or the preferred
%                       ratio of temporal frequency to spatial frequency
%                       (for V1 neurons). Direction is given in radians
%                       with 0 = right; speed is given in pixels per frame.
% 
% Output:
% pop       the responses of neurons in the population. Each row of pop
%           contains the responses of all neurons in the population with
%           identical tuning properties, but with receptive fields centered
%           at different spatial positions. Each column corresponds to a
%           the response of a neuron centered on some spatial position at
%           some time; it's not intuitive to say which. To extract more
%           intelligible responses, use shGetNeuron or shGetSubPop
% ind       a matrix of indices that lets you extract intelligible
%           responses from pop and res with shGetNeuron and shGetSubPop.
% res       the responses of additional neurons not in the population. Is
%           returned only if you have requested these responses by
%           supplying the optional argument additionalNeurons.

function varargout = shModel(varargin)
% get the pars object
stimulus = varargin{1};
pars = varargin{2};
stageName = varargin{3};

sSz = [size(stimulus, 1), size(stimulus, 2), size(stimulus, 3)];
if any(sSz < shGetDims(pars, stageName))
    errString = ['Stimulus is not large enough for computation of the ', ...
        stageName, ' stage.'];
    error(errString);
end
    
switch lower(stageName)
    case {'v1lin'}
        if nargin > 3
            [pop, ind, S, res] = shModelV1Linear(stimulus, pars, varargin{4});
        else
            [pop, ind, S] = shModelV1Linear(stimulus, pars);
        end

        varargout{1} = pop;
        varargout{2} = ind;
        varargout{3} = S;
        if nargin > 3
            varargout{3} = res;
            varargout{4} = S;
        end

    case {'v1halfrect'}
        [pop, ind] = shModelV1Linear(stimulus, pars);
        if nargin > 3
            [pop, ind, res] = shModelHalfWaveRectification(pop, ind, pars, varargin{4});
        else
            [pop, ind] = shModelHalfWaveRectification(pop, ind, pars);
        end
        varargout{1} = pop;
        varargout{2} = ind;
        if nargin > 3
            varargout{3} = res;
        end
        
    case {'v1simple'}
        [pop, ind] = shModelV1Linear(stimulus, pars);
        [pop, ind] = shModelHalfWaveRectification(pop, ind, pars);
        if nargin > 3
            [pop, ind, nume, deno, res, resnume, resdeno] = shModelV1Normalization(pop, ind, pars, varargin{4});
        else
            [pop, ind, nume, deno] = shModelV1Normalization(pop, ind, pars);
        end
        varargout{1} = pop;
        varargout{2} = ind;
        varargout{3} = nume;
        varargout{4} = deno;
        if nargin > 3
            varargout{3} = res;
            varargout{4} = nume;
            varargout{5} = deno;
            varargout{6} = resnume;
            varargout{7} = resdeno;
        end
        
    case {'v1fullrect'}
        [pop, ind] = shModelV1Linear(stimulus, pars);
        if nargin > 3
            [pop, ind, res] = shModelFullWaveRectification(pop, ind, pars, varargin{4});
        else
            [pop, ind] = shModelFullWaveRectification(pop, ind, pars);
        end
        varargout{1} = pop;
        varargout{2} = ind;
        if nargin > 3
            varargout{3} = res;
        end
        
    case {'v1blur'}
        [pop, ind] = shModelV1Linear(stimulus, pars);
        [pop, ind] = shModelFullWaveRectification(pop, ind, pars);
        if nargin > 3
            [pop, ind, res] = shModelV1Blur(pop, ind, pars, varargin{4});
        else
            [pop, ind] = shModelV1Blur(pop, ind, pars);
        end
        varargout{1} = pop;
        varargout{2} = ind;
        if nargin > 3
            varargout{3} = res;
        end
        
    case {'v1complex'}
        [pop, ind] = shModelV1Linear(stimulus, pars);
        [pop, ind] = shModelFullWaveRectification(pop, ind, pars);
        [pop, ind] = shModelV1Blur(pop, ind, pars);
        if nargin > 3
            [pop, ind, nume, deno, res, resnume, resdeno] = shModelV1Normalization(pop, ind, pars, varargin{4});
        else
            [pop, ind, nume, deno] = shModelV1Normalization(pop, ind, pars);
        end
        varargout{1} = pop;
        varargout{2} = ind;
        varargout{3} = nume;
        varargout{4} = deno;
        if nargin > 3
            varargout{3} = res;
            varargout{4} = nume;
            varargout{5} = deno;
            varargout{6} = resnume;
            varargout{7} = resdeno;
        end

    case {'mtlin'}
        [pop, ind] = shModelV1Linear(stimulus, pars);
        [pop, ind] = shModelFullWaveRectification(pop, ind, pars);
        [pop, ind] = shModelV1Blur(pop, ind, pars);
        [pop, ind, nume, deno] = shModelV1Normalization(pop, ind, pars);
        
        if nargin > 3
            [pop, ind, res] = shModelMtLinear(pop, ind, pars, varargin{4});
        else
            [pop, ind] = shModelMtLinear(pop, ind, pars);
        end
        varargout{1} = pop;
        varargout{2} = ind;
        if nargin > 3
            varargout{3} = res;
        end
        
    case {'mtprepool'} 
        [pop, ind] = shModelV1Linear(stimulus, pars);
        [pop, ind] = shModelFullWaveRectification(pop, ind, pars);
        [pop, ind] = shModelV1Blur(pop, ind, pars);
        [pop, ind, nume, deno] = shModelV1Normalization(pop, ind, pars);
        
        if nargin > 3
            [pop, ind, res] = shModelMtLinear(pop, ind, pars, varargin{4});
            [pop, ind, res] = shModelMtPreThresholdBlur(pop, ind, pars, res);
        else
            [pop, ind] = shModelMtLinear(pop, ind, pars);
            [pop, ind] = shModelMtPreThresholdBlur(pop, ind, pars);
        end
        
        varargout{1} = pop;
        varargout{2} = ind;
        if nargin > 3
            varargout{3} = res;
        end

    case {'mthalfrect'}
        [pop, ind] = shModelV1Linear(stimulus, pars);
        [pop, ind] = shModelFullWaveRectification(pop, ind, pars);
        [pop, ind] = shModelV1Blur(pop, ind, pars);
        [pop, ind, nume, deno] = shModelV1Normalization(pop, ind, pars);
        
        if nargin > 3
            [pop, ind, res] = shModelMtLinear(pop, ind, pars, varargin{4});
            [pop, ind, res] = shModelMtPreThresholdBlur(pop, ind, pars, res);
            [pop, ind, res] = shModelHalfWaveRectification(pop, ind, pars, res);
        else
            [pop, ind] = shModelMtLinear(pop, ind, pars);
            [pop, ind] = shModelMtPreThresholdBlur(pop, ind, pars);
            [pop, ind] = shModelHalfWaveRectification(pop, ind, pars);
        end
        
        varargout{1} = pop;
        varargout{2} = ind;
        if nargin > 3
            varargout{3} = res;
        end

    case {'mtpostpool'}
        [pop, ind] = shModelV1Linear(stimulus, pars);
        [pop, ind] = shModelFullWaveRectification(pop, ind, pars);
        [pop, ind] = shModelV1Blur(pop, ind, pars);
        [pop, ind, nume, deno] = shModelV1Normalization(pop, ind, pars);
        
        if nargin > 3
            [pop, ind, res] = shModelMtLinear(pop, ind, pars, varargin{4});
            [pop, ind, res] = shModelMtPreThresholdBlur(pop, ind, pars, res);
            [pop, ind, res] = shModelHalfWaveRectification(pop, ind, pars, res);
            [pop, ind, res] = shModelMtPostThresholdBlur(pop, ind, pars, res);
        else
            [pop, ind] = shModelMtLinear(pop, ind, pars);
            [pop, ind] = shModelMtPreThresholdBlur(pop, ind, pars);
            [pop, ind] = shModelHalfWaveRectification(pop, ind, pars);
            [pop, ind] = shModelMtPostThresholdBlur(pop, ind, pars);
        end
        
        varargout{1} = pop;
        varargout{2} = ind;
        if nargin > 3
            varargout{3} = res;
        end
        
    case {'mtpattern'}
        [pop, ind] = shModelV1Linear(stimulus, pars);
        [pop, ind] = shModelFullWaveRectification(pop, ind, pars);
        [pop, ind] = shModelV1Blur(pop, ind, pars);           % 160
        [pop, ind, nume, deno] = shModelV1Normalization(pop, ind, pars);

        
        if nargin > 3
            [pop, ind, res] = shModelMtLinear(pop, ind, pars, varargin{4});
            [pop, ind, res] = shModelMtPreThresholdBlur(pop, ind, pars, res);
            [pop, ind, res] = shModelHalfWaveRectification(pop, ind, pars, res);
            [pop, ind, res] = shModelMtPostThresholdBlur(pop, ind, pars, res);
            [pop, ind, nume, deno, res, resnume, resdeno] = shModelMtNormalization(pop, ind, pars, res, varargin{4});
        else
            [pop, ind] = shModelMtLinear(pop, ind, pars);
            [pop, ind] = shModelMtPreThresholdBlur(pop, ind, pars);
            [pop, ind] = shModelHalfWaveRectification(pop, ind, pars);
            [pop, ind] = shModelMtPostThresholdBlur(pop, ind, pars);
            [pop, ind, nume, deno] = shModelMtNormalization(pop, ind, pars);
        end
        
        varargout{1} = pop;
        varargout{2} = ind;
        varargout{3} = nume;
        varargout{4} = deno;
        if nargin > 3           
            varargout{3} = res;
            varargout{4} = nume;
            varargout{5} = deno;
            varargout{6} = resnume;
            varargout{7} = resdeno;
        end    
end
