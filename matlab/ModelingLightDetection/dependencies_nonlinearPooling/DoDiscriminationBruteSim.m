% DoDiscriminationBruteSim%%	Discriminate between two simulated responses in arrays of cells (e.g. %	in photoreceptor array).  Split data into learn and test.  Calculate discriminant %	from learn and apply to test.%% Created 4/20/00 FMR%function PCorrect = DoDiscriminationBruteSim(ResponseA, ResponseB, RFRadius, Power, shuffles, Verbose)PCorrect = 0;						% probability correctNumIterations = size(ResponseA, 4);	% number of simulated responsesSegLength = size(ResponseA, 3);		% length of each simulated responseRodMatrixSize = size(ResponseA, 1);		% number of elements in each simulated responselist = 1:NumIterations;				% list for resamplingrespA(1:SegLength) = 0;				% pooled response ArespB(1:SegLength) = 0;				% pooled response BrespA = respA';respB = respB';% receptive field weights for each rodRFWeightMatrix(1:RodMatrixSize, 1:RodMatrixSize) = 0;for XLoc = 1:RodMatrixSize	for YLoc = 1:RodMatrixSize		DistanceToRFCenter = (XLoc - RodMatrixSize/2).^2 + (YLoc - RodMatrixSize/2).^2;		RFWeightMatrix(XLoc, YLoc) = exp(-DistanceToRFCenter / (2 * RFRadius.^2));	endend% resample data shuffles times, using half as learn and half as test.for shuffle = 1:shuffles		if (Verbose)		fprintf(1, 'Shuffle %d\n', shuffle);	end		% shuffle list	ShuffledList = ShuffleList(list);	LearnList = ShuffledList(1:NumIterations/2);	TestList = ShuffledList(NumIterations/2+1:NumIterations);		% compute discriminant from first half of list	Discriminant = FindDiscriminantBruteSim(ResponseA, ResponseB, RFRadius, LearnList, Power);	% apply discriminant to second half		for cnt = 1:NumIterations/2		respA = 0;		respB = 0;		% compute pooled response		for XLoc = 1:RodMatrixSize			for YLoc = 1:RodMatrixSize				temp(1:SegLength) = ResponseA(XLoc, YLoc, 1:SegLength, TestList(cnt));				respA = respA + RFWeightMatrix(XLoc, YLoc) * (temp.^Power)';				temp(1:SegLength) = ResponseB(XLoc, YLoc, 1:SegLength, TestList(cnt));				respB = respB + RFWeightMatrix(XLoc, YLoc) * (temp.^Power)';			end		end		% compute projections and update probability correct		RespAVal = sum(respA' .* Discriminant);		RespBVal = sum(respB' .* Discriminant);		if (RespAVal > RespBVal)			PCorrect = PCorrect + 1;		end		if (RespAVal == RespBVal)			PCorrect = PCorrect + 0.5;		end		if (Verbose)			if (rem(cnt, 10) == 0)				fprintf(1, '\t%d: Probability Correct = %d\n', cnt, PCorrect/((shuffle-1) * (NumIterations/2-1) + cnt));			end		end		endendPCorrect = PCorrect / (NumIterations/2 * shuffles);fprintf(1, 'Power = %d Probability Correct = %d\n', Power, PCorrect);