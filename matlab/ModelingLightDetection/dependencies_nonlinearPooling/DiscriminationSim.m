% DiscriminationSim.m%% Created 6/00 FMR, conversion to tutorial format JLG 6/00.%% In a two alternative forced choice task where primates (humans?) are% required to judge whether a very dim flash of light occurs in one% of two intervals, primates (humans?) display an amazing ability to% detect very dim flashes of light. Humans can reliably?? detect a% dim light composed of X? 1-2? photons light. This ability is quite% remarkable given the fact that rods have inherent noise in them.% %%%%%	Simulate the flash responses in rod array to two stimuli% and do two-alternative forced choice discrimination.  Includes ability% to apply power-law nonlinearity to each rod signal prior to pooling.  % Specifics of simulation of individual rod responses are in % GenerateRodCurrent.  FindDiscriminantBruteSim calculates a discrimination % template as the difference in the mean time courses of the responses to each stimulus. %% simulation parametersNumIterations = 50;				% number of simulated trialsSegLength = 128;				% number of time points in each rod responseRodPoolDimension = 12;			% simulated rod array is square with this many rods along one sideMeanPhosA = 0.02;				% mean number of photons absorbed in first response group ('correct' responses)MeanPhosB = 0.00001;			% mean number of photons absorbed in second response group ('incorrect' responses)FlashTimeA = 1;					% time point in which flash occurs in first response groupFlashTimeB = 1;					% time point in which flash occurs in second response groupshuffles = 5;					% number of shuffles for bootstrap resamplingVerbose = 1;					% prints lots of crap to command windowRFRadius = 4;					% radius of circularly symmetric Gaussian receptive fieldPower = 1;						% parameter of power-law nonlinearity applied to each rod response before pooling% generate simulated responses to each stimulus% stimulus A is assumed the 'correct' stimulus in the 2AFC analysisRodResponseA = SimulateRodArrayResponse(RodPoolDimension, NumIterations, MeanPhosA, SegLength, FlashTimeA);RodResponseB = SimulateRodArrayResponse(RodPoolDimension, NumIterations, MeanPhosB, SegLength, FlashTimeB);% check discrimination at single powerlist = 1:NumIterations;Power = 1;Discriminant = FindDiscriminantBruteSim(RodResponseA, RodResponseB, RFRadius, list, 1);plot(Discriminant);DoDiscriminationBruteSim(RodResponseA, RodResponseB, RFRadius, Power, shuffles, Verbose);% check scaling with power applied to each rod responsePow(1:5) = 0;PCor(1:5) = 0;for n=1:5	Pow(n) = 2*n-1;	PCor(n) = DoDiscriminationBruteSim(RodResponseA, RodResponseB, RFRadius, Pow(n), shuffles, Verbose);endplot(Pow, PCor)% check simulation parameters[Ave,Var] = AveAndVarSim(RodResponseA);tme = 1:length(Ave);plot(tme, Ave, tme, Var);